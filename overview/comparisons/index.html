<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Estuary Flow RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Estuary Flow Atom Feed"><title data-react-helmet="true">Comparisons | Estuary Flow</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://docs.estuary.dev/overview/comparisons/"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Comparisons | Estuary Flow"><meta data-react-helmet="true" name="description" content="High level explanations of Flow in terms of the systems you already know"><meta data-react-helmet="true" property="og:description" content="High level explanations of Flow in terms of the systems you already know"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://docs.estuary.dev/overview/comparisons/"><link data-react-helmet="true" rel="alternate" href="https://docs.estuary.dev/overview/comparisons/" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.estuary.dev/overview/comparisons/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f28ed1e5.css">
<link rel="preload" href="/assets/js/runtime~main.4a1bbd1c.js" as="script">
<link rel="preload" href="/assets/js/main.324620e7.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/EstuaryAnimated.gif" alt="Estuary Flow Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/EstuaryAnimated.gif" alt="Estuary Flow Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">Estuary Flow</b></a><a class="navbar__item navbar__link navbar__link--active" href="/">Documentation</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/estuary/flow" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_TwRn" href="/">Overview</a><button aria-label="Toggle the collapsible sidebar category &#x27;Overview&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/overview/who-should-use-flow/">Who should use Flow?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/overview/comparisons/">Comparisons</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/getting-started/installation/">Getting started</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_TwRn" href="/concepts/">Concepts</a><button aria-label="Toggle the collapsible sidebar category &#x27;Concepts&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/guides/create-dataflow/">Guides</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/reference/reduction-strategies/">Reference</a></div></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Comparisons</h1></header><p>Flow is a flexible platform for real-time data processing. It integrates data ingestion, storage, transformation, and materialization. However, you may find that description isn&#x27;t enough to give you a true understanding of what Flow does in practical terms.</p><p>This article is designed to provide clarity by explaining Flow through the lens of various data systems you may know. For each system, it discusses Flow&#x27;s similarities and differences, and how the two can be used together, when applicable.</p><p>Because Flow combines many functionalities, it is related to multiple types of technologies. Click the familiar system(s) from the list below to jump to an explanation of how it compares with Flow.</p><ul><li><a href="/overview/comparisons/#apache-beam-and-google-cloud-dataflow">Apache Beam and Google Cloud Dataflow</a></li><li><a href="/overview/comparisons/#kafka">Kafka</a></li><li><a href="/overview/comparisons/#spark">Spark</a></li><li><a href="/overview/comparisons/#hadoop-hdfs-and-hive">Hadoop, HDFS, and Hive</a></li><li><a href="/overview/comparisons/#fivetran-airbyte-and-other-elt-solutions">Fivetran, Airbyte, and other ELT solutions</a></li><li><a href="/overview/comparisons/#dbt">dbt</a></li><li><a href="/overview/comparisons/#materialize-rockset-ksqldb-and-other-real-time-databases">Materialize, Rockset, ksqlDB, and other realtime databases</a></li><li><a href="/overview/comparisons/#snowflake-bigquery-and-other-olap-databases">Snowflake, BigQuery, and other OLAP databases</a></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="apache-beam-and-google-cloud-dataflow">Apache Beam and Google Cloud Dataflow<a class="hash-link" href="#apache-beam-and-google-cloud-dataflow" title="Direct link to heading">â€‹</a></h2><p>Flowâ€™s most apt comparison is to Apache Beam. You may use a variety of runners (processing engines) for your Beam deployment. One of the most popular, Google Cloud Dataflow, is a more robust redistribution under an additional SDK. Regardless of how you use Beam, thereâ€™s a lot of conceptual overlap with Flow. This makes Beam and Flow alternatives rather than complementary technologies, but there are key differences.</p><p>Like Beam, Flowâ€™s primary primitive is a collection. You build a processing graph (called a <strong>pipeline</strong> in Beam and a <strong>catalog</strong> in Flow) by relating multiple collections together through procedural transformations, or lambdas. As with Beam, Flowâ€™s runtime performs automatic data shuffles and is designed to allow fully automatic scaling. Also like Beam, collections have associated schemas.</p><p>Unlike Beam, Flow doesnâ€™t distinguish between batch and streaming contexts. Flow unifies these paradigms under a single collection concept, allowing you to seamlessly work with both data types.</p><p>Also, while Beam allows you the option to define combine operators, Flowâ€™s runtime always applies combine operators. These are built using the declared semantics of the documentâ€™s schema, which makes it much more efficient and cost-effective to work with streaming data.</p><p>Finally, Flow allows stateful stream-to-stream joins without the windowing semantics imposed by Beam. Notably, Flowâ€™s modeling of state â€“ via its per-key <strong>register</strong> concept â€“ is substantially more powerful than Beam&#x27;s per-key-and-window model. For example, registers can trivially model the cumulative lifetime value of a customer.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="kafka">Kafka<a class="hash-link" href="#kafka" title="Direct link to heading">â€‹</a></h2><p>Flow inhabits a different space than Kafka does by itself. Kafka is an infrastructure that supports streaming applications running elsewhere. Flow is an opinionated framework for working with real-time data. You might think of Flow as an analog to an opinionated bundling of several important features from the broader Kafka ecosystem.</p><p>Flow is built on <a href="https://gazette.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer">Gazette</a>, a highly-scalable streaming broker similar to log-oriented pub/sub systems. Thus, Kafka is more directly comparable to Gazette. Flow also uses Gazetteâ€™s consumer framework, which has similarities to Kafka <strong>consumers</strong>. Both manage scale-out execution contexts for consumer tasks, offer durable local task stores, and provide exactly-once semantics.</p><p><a href="/concepts/journals/">Journals</a> in Gazette and Flow are roughly analogous to Kafka <strong>partitions</strong>. Each journal is a single append-only log. Gazette has no native notion of a <strong>topic</strong>, but instead supports label-based selection of subsets of journals, which tends to be more flexible. Gazette journals store data in contiguous chunks called <strong>fragments</strong>, which typically live in cloud storage. Each journal can have its own separate storage configuration, which Flow leverages to allow users to bring their own cloud storage buckets. Another unique feature of Gazette is its ability to serve reads of historical data by providing clients with pre-signed cloud storage URLs, which enables it to serve many readers very efficiently.</p><p>Generally, Flow users don&#x27;t need to know or care much about Gazette and its architecture, since Flow provides a higher-level interface over groups of journals, called <strong>collections</strong>.</p><p>Flow <a href="/concepts/collections/">collections</a> are somewhat similar to Kafka <strong>streams</strong>, but with some important differences. Collections always store JSON and must have an associated JSON schema. Collections also support automatic logical and physical partitioning. Each collection is backed by one or more journals, depending on the partitioning.</p><p>Flow <a href="/concepts/#tasks">tasks</a> are most similar to Kafka <strong>stream processors</strong>, but are more opinionated. Tasks fall into one of three categories: captures, derivations, and materializations. Tasks may also have more than one process, which Flow calls <strong>shards</strong>, to allow for parallel processing. Tasks and shards are fully managed by Flow. This includes transactional state management and zero-downtime splitting of shards, which enables turnkey scaling.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="spark">Spark<a class="hash-link" href="#spark" title="Direct link to heading">â€‹</a></h2><p>Spark can be described as a batch engine with stream processing add-ons, where Flow is fundamentally a streaming system that is able to easily integrate with batch systems.</p><p>You can think of a Flow <strong>collection</strong> as a set of RDDs with common associated metadata. In Spark, you can save an RDD to a variety of external systems, like cloud storage or a database. Likewise, you can load from a variety of external systems to create an RDD. Finally, you can transform one RDD into another. You use Flow collections in a similar manner. They represent a logical dataset, which you can <strong>materialize</strong> to push the data into some external system like cloud storage or a database. You can also create a collection that is <strong>derived</strong> by applying stateful transformations to one or more source collections.</p><p>Unlike Spark RDDs, Flow collections are backed by one or more unbounded append-only logs. Therefore, you don&#x27;t create a new collection each time data arrives; you simply append to the existing one. Collections can be partitioned and can support extremely large volumes of data.</p><p>Spark&#x27;s processing primitives, <strong>applications</strong>, <strong>jobs</strong>, and <strong>tasks</strong>, don&#x27;t translate perfectly to Flow, but we can make some useful analogies. This is partly because Spark is not very opinionated about what an application does. Your Spark application could read data from cloud storage, then transform it, then write the results out to a database. The closest analog to a Spark application in Flow is the <strong>catalog</strong>. A Flow catalog is a composition of Flow tasks, which are quite different from tasks in Spark.</p><p>In Flow, a task is a logical unit of work that does <em>one</em> of capture (ingest), derive (transform), or materialize (write results to an external system). What Spark calls a task is actually closer to a Flow <strong>shard</strong>. In Flow, a task is a logical unit of work, and <a href="/concepts/shards/">shards</a> represent the potentially numerous processes that actually carry out that work. Shards are the unit of parallelism in Flow, and you can easily split them for turnkey scaling.</p><p>Composing Flow tasks is also a little different than composing Spark jobs. Flow tasks always produce and/or consume data in collections, instead of piping data directly from one shard to another. This is because every task in Flow is transactional and, to the greatest degree possible, fault-tolerant. This design also affords painless backfills of historical data when you want to add new transformations or materializations.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="hadoop-hdfs-and-hive">Hadoop, HDFS, and Hive<a class="hash-link" href="#hadoop-hdfs-and-hive" title="Direct link to heading">â€‹</a></h2><p>There are many different ways to use Hadoop, HDFS, and the ecosystem of related projects, several of which are useful comparisons to Flow.</p><p>To gain an understanding of Flow&#x27;s processing model for derivations, see <a href="https://www.estuary.dev/why-mapreduce-is-making-a-comeback/" target="_blank" rel="noopener noreferrer">this blog post about MapReduce in Flow</a>.</p><p>HDFS is sometimes used as a system of record for analytics data, typically paired with an orchestration system for analytics jobs. If you do this, you likely export datasets from your source systems into HDFS. Then, you use some other tool to coordinate running various MapReduce jobs, often indirectly through systems like Hive.</p><p>For this use case, the best way of describing Flow is that it completely changes the paradigm. In Flow, you always append data to existing <strong>collections</strong>, rather than creating a new one each time a job is run. In fact, Flow has no notion of a <strong>job</strong> like there is in Hadoop. Flow tasks run continuously and everything stays up to date in real time, so there&#x27;s never a need for outside orchestration or coordination. Put simply, Flow collections are log-like, and files in HDFS typically store table-like data. <a href="https://www.estuary.dev/the-power-and-implications-of-data-materialization/" target="_blank" rel="noopener noreferrer">This blog post</a> explores those differences in greater depth.</p><p>To make this more concrete, imagine a hypothetical example of a workflow in the Hadoop world where you export data from a source system, perform some transformations, and then run some Hive queries.</p><p>In Flow, you instead define a <strong>capture</strong> of data from the source, which runs continuously and keeps a collection up to date with the latest data from the source. Then you transform the data with Flow <strong>derivations</strong>, which again apply the transformations incrementally and in real time. While you <em>could</em> actually use tools like Hive to directly query data from Flow collections â€” the layout of collection data in cloud storage is intentionally compatible with this â€” you could also <strong>materialize</strong> a view of your transformation results to any database, which is also kept up to date in real time.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="fivetran-airbyte-and-other-elt-solutions">Fivetran, Airbyte, and other ELT solutions<a class="hash-link" href="#fivetran-airbyte-and-other-elt-solutions" title="Direct link to heading">â€‹</a></h2><p>Tools like Fivetran and Airbyte are purpose-built to move data from one place to another. These ELT tools typically model sources and destinations, and run regularly scheduled jobs to export from the source directly to the destination. Flow models things differently. Instead of modeling the worlds in terms of independent scheduled jobs that copy data from source to destination, Flow catalogs model a directed graph of
<a href="/concepts/captures/"><strong>captures</strong></a> (reads from sources),
<a href="/concepts/derivations/"><strong>derivations</strong></a> (transforms), and
<a href="/concepts/materialization/"><strong>materializations</strong></a> (writes to destinations).
Collectively, these are called <em>tasks</em>.</p><p>Tasks in Flow are only indirectly linked. Captures read data from a source and output to <strong>collections</strong>. Flow collections store all the data in cloud storage, with configurable retention for historical data. You can then materialize each collection to any number of destination systems. Each one will be kept up to date in real time, and new materializations can automatically backfill all your historical data. Collections in Flow always have an associated JSON schema, and they use that to ensure the validity of all collection data. Tasks are also transactional and generally guarantee end-to-end exactly-once processing*.</p><p>Like Airbyte, Flow uses <a href="/concepts/connectors/">connectors</a> for interacting with external systems in captures and materializations. For captures,
Flow integrates the Airbyte specification,
so all Airbyte source connectors can be used with Flow.
For materializations, Flow uses its own protocol which is not compatible with the Airbyte spec.
In either case the usage of connectors is pretty similar.</p><p>In terms of technical capabilities, Flow can do everything that these tools can and more,
but those tools are more mature while Flow is currently in private beta.
Both Fivetran and Airbyte both currently have graphical interfaces that make them much easier for
non-technical users to configure, while Flow&#x27;s UI is under development.
Currently, Flow offers declarative YAML for configuration, which works excellently in a GitOps workflow.</p><p><em>* Some materialization endpoints can only make at-least-once guarantees.</em></p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="dbt">dbt<a class="hash-link" href="#dbt" title="Direct link to heading">â€‹</a></h2><p>dbt is a tool that enables data analysts and engineers to transform data in their warehouses more effectively.</p><p>In addition to â€“ and perhaps more important than â€“ its transform capability, dbt brought an entirely new workflow for working with data:
one that prioritizes version control, testing, local development, documentation, composition, and re-use.</p><p>Like dbt, Flow uses a declarative model and tooling, but the similarities end there. dbt is a tool for defining transformations, which are executed within your analytics warehouse.
Flow is a tool for delivering data to that warehouse, as well as continuous operational transforms that are applied everywhere else.</p><p>These two tools can make lots of sense to use together. First, Flow brings timely, accurate data to the warehouse.
Within the warehouse, analysts can use tools like dbt to explore the data. The Flow pipeline is then ideally suited to
productionize important insights as materialized views or by pushing to another destination.</p><p>Put another way, Flow is a complete ELT platform, but you might choose to perform and manage more complex transformations in
a separate, dedicated tool like dbt. While Flow and dbt donâ€™t interact directly, both offer easy integration through your data warehouse.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="materialize-rockset-ksqldb-and-other-real-time-databases">Materialize, Rockset, ksqlDB, and other real-time databases<a class="hash-link" href="#materialize-rockset-ksqldb-and-other-real-time-databases" title="Direct link to heading">â€‹</a></h2><p>Modern real-time databases like Materialize, Rockset, and ksqlDB consume streams of data, oftentimes from Kafka brokers,
and can keep SQL views up to date in real time.</p><p>These real-time databases have a lot of conceptual overlap with Flow. The biggest difference is that Flow can materialize this same type of incrementally updated view into any database, regardless of whether that database has real-time capabilities or not.<!-- --> </p><p>However, this doesn&#x27;t mean that Flow should always <em>replace</em> these systems in your stack. In fact, it can be optimal to use Flow to feed data into them. Doing so allows you to transactionally capture data from a variety of sources and transform it along the way. For further explanation, read the section below on OLAP databases.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="snowflake-bigquery-and-other-olap-databases">Snowflake, BigQuery, and other OLAP databases<a class="hash-link" href="#snowflake-bigquery-and-other-olap-databases" title="Direct link to heading">â€‹</a></h2><p>Flow differs from OLAP databases mainly in that it&#x27;s not a database. Flow has no query interface, and no plans to add one. Instead, Flow allows you to use the query interfaces of any database by <strong>materializing</strong> views into it.</p><p>Flow is similar to OLAP databases in that it can be the source of truth for all analytics data (though it&#x27;s also capable enough to handle operational workloads). Instead of schemas and tables, Flow catalogs define <strong>collections</strong>. These collections are conceptually similar to database tables in the sense that they are containers for data with an associated (primary) key. Under the hood, Flow collections are each backed by append-only logs, where each document in the log represents a delta update for a given key.</p><p>Collections can be easily materialized into a variety of external systems, such as Snowflake or BigQuery. This creates a table in your OLAP database that is continuously kept up to date with the collection. With Flow, there&#x27;s no need to schedule exports to these systems, and thus no need to orchestrate the timing of those exports. You can also materialize a given collection into multiple destination systems, so you can always use whichever system is best for the type of queries you want to run.</p><p>Like Snowflake, Flow uses inexpensive cloud storage for all collection data. It even lets you bring your own storage bucket, so you&#x27;re always in control. Unlike data warehouses, Flow is able to directly capture data from source systems, and continuously and incrementally keep everything up to date.</p><p>A common pattern is to use Flow to capture data from multiple different sources and materialize it into a data warehouse. Flow can also help you avoid expenses associated with queries you frequently pull from a data warehouse by keeping an up-to-date view of them where you want it. Because of Flowâ€™s exactly-once processing guarantees, these materialized views are always correct, consistent, and fault-tolerant.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/estuary/flow/edit/master/site/docs/overview/comparisons.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/overview/who-should-use-flow/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Who should use Flow?</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/getting-started/installation/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Setting up a development environment</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#apache-beam-and-google-cloud-dataflow" class="table-of-contents__link toc-highlight">Apache Beam and Google Cloud Dataflow</a></li><li><a href="#kafka" class="table-of-contents__link toc-highlight">Kafka</a></li><li><a href="#spark" class="table-of-contents__link toc-highlight">Spark</a></li><li><a href="#hadoop-hdfs-and-hive" class="table-of-contents__link toc-highlight">Hadoop, HDFS, and Hive</a></li><li><a href="#fivetran-airbyte-and-other-elt-solutions" class="table-of-contents__link toc-highlight">Fivetran, Airbyte, and other ELT solutions</a></li><li><a href="#dbt" class="table-of-contents__link toc-highlight">dbt</a></li><li><a href="#materialize-rockset-ksqldb-and-other-real-time-databases" class="table-of-contents__link toc-highlight">Materialize, Rockset, ksqlDB, and other real-time databases</a></li><li><a href="#snowflake-bigquery-and-other-olap-databases" class="table-of-contents__link toc-highlight">Snowflake, BigQuery, and other OLAP databases</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/">Flow Documentation</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/EstuaryDev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/estuary/flow" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 Estuary Technologies, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4a1bbd1c.js"></script>
<script src="/assets/js/main.324620e7.js"></script>
</body>
</html>