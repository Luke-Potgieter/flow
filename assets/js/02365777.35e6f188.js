"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2708],{1504:function(e,t,a){var n=a(7294),o=a(7273);o.Z.initialize({startOnLoad:!0});t.Z=function(e){var t=e.chart;return(0,n.useEffect)((function(){o.Z.contentLoaded()}),[]),n.createElement("div",{className:"mermaid"},t)}},9683:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var n=a(7462),o=a(3366),i=(a(7294),a(3905)),s=a(1504),r=["components"],l={},c="Concepts",d={unversionedId:"concepts/README",id:"concepts/README",title:"Concepts",description:"Flow helps you define data pipelines, known as data flows, that connect your data systems, APIs, and storage, and optionally transform data along the way.",source:"@site/docs/concepts/README.md",sourceDirName:"concepts",slug:"/concepts/",permalink:"/concepts/",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Configure connections with SSH tunneling",permalink:"/guides/connect-network"},next:{title:"Captures",permalink:"/concepts/captures"}},p={},u=[{value:"Catalogs",id:"catalogs",level:2},{value:"Namespace",id:"namespace",level:3},{value:"Builds",id:"builds",level:3},{value:"Specifications",id:"specifications",level:3},{value:"Collections",id:"collections",level:2},{value:"Journals",id:"journals",level:3},{value:"Captures",id:"captures",level:2},{value:"Materializations",id:"materializations",level:2},{value:"Derivations",id:"derivations",level:2},{value:"Schemas",id:"schemas",level:2},{value:"Constraints",id:"constraints",level:3},{value:"Projections",id:"projections",level:3},{value:"Reductions",id:"reductions",level:3},{value:"Key strategies",id:"key-strategies",level:3},{value:"Tasks",id:"tasks",level:2},{value:"Task shards",id:"task-shards",level:3},{value:"Endpoints",id:"endpoints",level:2},{value:"Resources",id:"resources",level:3},{value:"Connectors",id:"connectors",level:3},{value:"Discovery",id:"discovery",level:3},{value:"Tests",id:"tests",level:2},{value:"Storage mappings",id:"storage-mappings",level:2},{value:"flowctl",id:"flowctl",level:2}],m={toc:u};function h(e){var t=e.components,l=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"concepts"},"Concepts"),(0,i.kt)("p",null,"Flow helps you define data pipelines, known as ",(0,i.kt)("strong",{parentName:"p"},"data flows"),", that connect your data systems, APIs, and storage, and optionally transform data along the way.\nData flows are defined in a Flow ",(0,i.kt)("a",{parentName:"p",href:"#catalogs"},"catalog")," and deployed using either the web application or the ",(0,i.kt)("a",{parentName:"p",href:"#flowctl"},"flowctl")," command-line interface."),(0,i.kt)("p",null,"This page provides a high-level explanation of concepts and terminology that will help you begin working with Flow and better understand its underlying mechanisms.\nThese concepts are further discussed in more detail on dedicated pages of this section."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(982).Z,width:"960",height:"540"})),(0,i.kt)("h2",{id:"catalogs"},"Catalogs"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"catalog")," comprises all the components that describe how your data flows function and behave:\ncaptures, collections, derivations, materializations, tests, and more. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"How to ",(0,i.kt)("strong",{parentName:"li"},"capture")," data from source systems into ",(0,i.kt)("strong",{parentName:"li"},"collections")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("strong",{parentName:"li"},"schemas")," of those collections, which Flow enforces"),(0,i.kt)("li",{parentName:"ul"},"How to ",(0,i.kt)("strong",{parentName:"li"},"derive")," collections as transformations of other source collections"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Materializations")," of collections into destination systems"),(0,i.kt)("li",{parentName:"ul"},"Your ",(0,i.kt)("strong",{parentName:"li"},"tests")," of schema and derivation behaviors")),(0,i.kt)("p",null,"Together the captures, collections, derivations, and materializations of your catalog\nform a graph of your data flows:"),(0,i.kt)(s.Z,{chart:"\n\tgraph LR;\n\t\tcapture/two--\x3ecollection/D;\n\t\tcapture/one--\x3ecollection/C;\n\t\tcapture/one--\x3ecollection/A;\n        collection/A--\x3ederivation/B;\n        collection/D--\x3ederivation/E;\n        collection/C--\x3ederivation/E;\n        derivation/B--\x3ederivation/E;\n\t\tcollection/D--\x3ematerialization/one;\n\t\tderivation/E--\x3ematerialization/two;\n",mdxType:"Mermaid"}),(0,i.kt)("h3",{id:"namespace"},"Namespace"),(0,i.kt)("p",null,"All catalog entities (captures, materializations, and collections) are identified by a ",(0,i.kt)("strong",{parentName:"p"},"name"),"\nsuch as ",(0,i.kt)("inlineCode",{parentName:"p"},"acmeCo/teams/manufacturing/anvils"),". Names have directory-like\nprefixes and every name within Flow is globally unique."),(0,i.kt)("p",null,"If you've ever used database schemas to organize your tables and authorize access,\nyou can think of name prefixes as being akin to database schemas with arbitrary nesting."),(0,i.kt)("p",null,"All catalog entities exist together in a single ",(0,i.kt)("strong",{parentName:"p"},"namespace"),".\nAs a Flow customer, you're provisioned one or more high-level prefixes for your organization.\nFurther division of the namespace into prefixes is up to you."),(0,i.kt)("p",null,"Prefixes of the namespace, like ",(0,i.kt)("inlineCode",{parentName:"p"},"acmeCo/teams/manufacturing/"),",\nare the foundation for Flow's authorization model."),(0,i.kt)("h3",{id:"builds"},"Builds"),(0,i.kt)("p",null,"Catalog entities like collections are very long-lived and may evolve over time.\nA collection's schema might be extended with new fields,\nor a transformation might be updated with a bug fix."),(0,i.kt)("p",null,"When one or more catalog entities are updated,\na catalog ",(0,i.kt)("strong",{parentName:"p"},"build")," validates their definitions and prepares them for execution by Flow's runtime.\nEvery build is assigned a unique identifier called a ",(0,i.kt)("strong",{parentName:"p"},"build ID"),",\nand the build ID is used to reconcile which version of a catalog entity\nis being executed by the runtime."),(0,i.kt)("p",null,"A catalog build is ",(0,i.kt)("strong",{parentName:"p"},"activated")," into Flow's runtime to deploy its captures, collections, and so on,\npossibly replacing an older build under which they had been running."),(0,i.kt)("h3",{id:"specifications"},"Specifications"),(0,i.kt)("p",null,"A catalog build begins from a set of ",(0,i.kt)("strong",{parentName:"p"},"catalog specifications"),"\nwhich define the behavior of your catalog:\nthe entities it contains, like captures, collections, and materializations,\nand their specific behaviors and configuration."),(0,i.kt)("p",null,'You define catalog specifications using either the Flow web application,\nor by directly creating and editing YAML or JSON files which are typically managed\nin a Git repository using familiar developer workflows (often called "GitOps").'),(0,i.kt)("p",null,"These files use the extension ",(0,i.kt)("inlineCode",{parentName:"p"},"*.flow.yaml")," or simply ",(0,i.kt)("inlineCode",{parentName:"p"},"flow.yaml")," by convention.\nAs a practical benefit, using this extension activates Flow's VS Code integration and auto-complete.\nFlow integrates with VS Code for development environment support, like auto-complete,\ntooltips, and inline documentation."),(0,i.kt)("p",null,"Depending on your catalog, you may also have TypeScript modules,\nJSON schemas, or test fixtures which are also managed in your Git repository."),(0,i.kt)("p",null,"Whether you use the web app or Git-managed specifications is up to you,\nand teams can switch back and forth depending on what's more familiar."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The Flow web application is currently in ",(0,i.kt)("a",{parentName:"p",href:"https://go.estuary.dev/sign-up"},"private beta"),"."))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"collections"},"Collections"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Collections")," are the fundamental representation for datasets within Flow, akin to a database table.\nMore technically, they're a collection of documents having a common ",(0,i.kt)("strong",{parentName:"p"},"key")," and ",(0,i.kt)("a",{parentName:"p",href:"#schemas"},"schema"),"."),(0,i.kt)("p",null,"Data in collections is not modelled as a table, however.\nCollections are best described as a real-time data lake:\ndocuments are stored as an organized layout of JSON files in your cloud storage bucket.\nIf Flow needs to read historical data \u2014 say, as part of creating a new materialization \u2014\nit does so by reading from your bucket.\nYou can use regular bucket lifecycle policies to manage the deletion of data from a collection.\nHowever, capturing ",(0,i.kt)("em",{parentName:"p"},"into")," a collection or materializing ",(0,i.kt)("em",{parentName:"p"},"from")," a collection happens within milliseconds."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/collections"},"Learn more about collections")),(0,i.kt)("h3",{id:"journals"},"Journals"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Journals")," provide the low-level storage for Flow collections.\nEach logical and physical partition of a collection is backed by a journal."),(0,i.kt)("p",null,"Task ",(0,i.kt)("a",{parentName:"p",href:"#task-shards"},"shards")," also use journals to provide for their durability\nand fault tolerance.\nEach shard has an associated ",(0,i.kt)("strong",{parentName:"p"},"recovery log"),", which is a journal into which\ninternal checkpoint states are written."),(0,i.kt)("p",null,"Journals and shards are advanced topics that may be beneficial for specialized engineering applications."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/advanced/journals"},"Learn more about journals")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"captures"},"Captures"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"capture")," is a Flow task that connects to a source endpoint system\nand binds one or more of its resources (tables, streams, etc) to Flow collections.\nData continuously flows from each resource in the endpoint to its Flow collection;\nas new data become available at the source,\nFlow validates their schema and adds them to their bound collection."),(0,i.kt)("p",null,"There are two categories of captures:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Pull")," captures which pull documents from an endpoint using a ",(0,i.kt)("a",{parentName:"li",href:"#connectors"},"connector"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Push")," captures which expose an URL endpoint which can be directly written into, such as via a Webhook POST.")),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Push captures are under development."))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/captures"},"Learn more about captures")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"materializations"},"Materializations"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"materialization")," is a catalog task that connects to an destination endpoint system\nand binds one or more collections to corresponding resources (tables, etc) in that system.\nData continuously flows from each Flow collection into its corresponding resource in the endpoint.\nMaterializations are the conceptual inverse of ",(0,i.kt)("strong",{parentName:"p"},"captures.")),(0,i.kt)("p",null,"As new documents become available within bound collections, the materialization\nkeeps endpoint resources up to date using precise, incremental updates.\nLike captures, materializations are powered by ",(0,i.kt)("a",{parentName:"p",href:"#connectors"},"connectors"),"."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/materialization"},"Learn more about materializations")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"derivations"},"Derivations"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"derivation")," is a collection that continuously\nderives its documents from transformations that are applied\nto one or more source collections."),(0,i.kt)("p",null,"You can use derivations to map, reshape, and filter documents.\nThey can also be used to tackle complex stateful streaming workflows,\nincluding joins and aggregations,\nand are not subject to the windowing and scaling limitations that are common to other systems."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"derivations/"},"Learn more about derivations")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"schemas"},"Schemas"),(0,i.kt)("p",null,"All collections in Flow have an associated\n",(0,i.kt)("a",{parentName:"p",href:"https://json-schema.org/understanding-json-schema/"},"JSON schema"),"\nagainst which documents are validated every time they're written or read.\nSchemas are key to how Flow ensures the integrity of your data.\nFlow validates your documents to ensure that\nbad data doesn't make it into your collections \u2014 or worse,\ninto downstream data products!"),(0,i.kt)("p",null,"Flow pauses catalog tasks when documents don't match the collection schema,\nalerting you to the mismatch and allowing you to fix it before it creates a bigger problem."),(0,i.kt)("h3",{id:"constraints"},"Constraints"),(0,i.kt)("p",null,"JSON schema is a flexible standard for representing structure, invariants,\nand other constraints over your documents."),(0,i.kt)("p",null,'Schemas can be very permissive, highly exacting, or somewhere in between.\nJSON schema goes far beyond checking basic document structure.\nIt also supports conditionals and invariants like\n"I expect all items in this array to be unique",\nor "this string must be an email",\nor "this integer must be between a multiple of 10 and in the range 0-100".'),(0,i.kt)("h3",{id:"projections"},"Projections"),(0,i.kt)("p",null,"Flow leverages your JSON schemas to produce other types of schemas as needed,\nsuch as TypeScript types and SQL ",(0,i.kt)("inlineCode",{parentName:"p"},"CREATE TABLE")," statements."),(0,i.kt)("p",null,"In many cases these projections provide comprehensive end-to-end type safety\nof Flow catalogs and their TypeScript transformations, all statically verified\nwhen the catalog is built."),(0,i.kt)("h3",{id:"reductions"},"Reductions"),(0,i.kt)("p",null,"Flow ",(0,i.kt)("a",{parentName:"p",href:"#collections"},"collections")," have a defined ",(0,i.kt)("strong",{parentName:"p"},"key"),", which is akin to\na database primary key declaration and determines how documents of the\ncollection are grouped.\nWhen a collection is materialized into a database table, its key becomes\nthe SQL primary key of the materialized table."),(0,i.kt)("p",null,"This of course raises the question: what happens if ",(0,i.kt)("em",{parentName:"p"},"multiple"),' documents\nof a given key are added to a collection?\nYou might expect that the last-written document is the effective document for\nthat key. This "last write wins" treatment is how comparable systems behave,\nand is also Flow\'s default.'),(0,i.kt)("p",null,"Flow also offers schema ",(0,i.kt)("strong",{parentName:"p"},"extensions"),"\nthat give you substantially more control over how documents are combined and reduced.\n",(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," annotations let you deeply merge documents, maintain running counts,\nand achieve other complex aggregation behaviors."),(0,i.kt)("h3",{id:"key-strategies"},"Key strategies"),(0,i.kt)("p",null,"Reduction annotations change the common patterns for how you think about collection keys."),(0,i.kt)("p",null,"Suppose you are building a reporting fact table over events of your business.\nToday you would commonly consider a unique event ID to be its natural key.\nYou would load all events into your warehouse and perform query-time aggregation.\nWhen that becomes too slow, you periodically refresh materialized views for fast-but-stale queries."),(0,i.kt)("p",null,"With Flow, you instead use a collection key of your ",(0,i.kt)("em",{parentName:"p"},"fact table dimensions"),",\nand use ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," annotations to define your metric aggregations.\nA materialization of the collection then maintains a\ndatabase table which is keyed on your dimensions,\nso that queries are both fast ",(0,i.kt)("em",{parentName:"p"},"and")," up to date."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/schemas"},"Learn more about schemas")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"tasks"},"Tasks"),(0,i.kt)("p",null,"Captures, derivations, and materializations are collectively referred to as catalog ",(0,i.kt)("strong",{parentName:"p"},"tasks"),'.\nThey are the "active" components of a catalog, each running continuously and reacting to documents\nas they become available.'),(0,i.kt)("p",null,"Collections, by way of comparison, are inert. They reflect data at rest, and are acted upon by\ncatalog tasks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A capture adds documents to a collection pulled from a source endpoint."),(0,i.kt)("li",{parentName:"ul"},"A derivation updates a collection by applying transformations to other collections."),(0,i.kt)("li",{parentName:"ul"},"A materialization reacts to changes of a collection to update a destination endpoint.")),(0,i.kt)("h3",{id:"task-shards"},"Task shards"),(0,i.kt)("p",null,"Task ",(0,i.kt)("strong",{parentName:"p"},"shards")," are the unit of execution for a catalog ",(0,i.kt)("a",{parentName:"p",href:"#tasks"},"task"),".\nA single task can have many shards, which allow the task to scale across\nmany machines to achieve more throughput and parallelism."),(0,i.kt)("p",null,"Shards are created and managed by the Flow runtime.\nEach shard represents a slice of the overall work of the catalog task,\nincluding its processing status and associated internal checkpoints.\nCatalog tasks are created with a single shard,\nwhich can be repeatedly subdivided at any time \u2014 with no downtime \u2014 to\nincrease the processing capacity of the task."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/advanced/shards"},"Learn more about shards")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"endpoints"},"Endpoints"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Endpoints")," are the external systems that you connect using Flow.\nAll kinds of systems can be endpoints: databases, key/value stores, streaming pub/sub systems, SaaS APIs, and cloud storage locations."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"#captures"},"Captures")," pull or ingest data ",(0,i.kt)("em",{parentName:"p"},"from")," an endpoint, while ",(0,i.kt)("a",{parentName:"p",href:"#materializations"},"materializations")," push data ",(0,i.kt)("em",{parentName:"p"},"into")," an endpoint.\nThere's an essentially unbounded number of different systems and APIs to which Flow might need to capture or materialize data.\nRather than attempt to directly integrate them all, Flow's runtime communicates with endpoints through plugin ",(0,i.kt)("a",{parentName:"p",href:"#connectors"},"connectors"),"."),(0,i.kt)("h3",{id:"resources"},"Resources"),(0,i.kt)("p",null,"An endpoint ",(0,i.kt)("strong",{parentName:"p"},"resource")," is an addressable collection of data within an endpoint.\nThe exact meaning of a resource is up to the endpoint and its connector. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Resources of a database endpoint might be its individual tables."),(0,i.kt)("li",{parentName:"ul"},"Resources of a Kafka cluster might be its topics."),(0,i.kt)("li",{parentName:"ul"},"Resources of a SaaS connector might be its various API feeds.")),(0,i.kt)("h3",{id:"connectors"},"Connectors"),(0,i.kt)("p",null,"There are ",(0,i.kt)("em",{parentName:"p"},"lots")," of potential endpoints where you want to work with data.\nThough Flow is a unified platform for data synchronization,\nit's impractical for any single company \u2014 Estuary included \u2014 to provide an integration for every\npossible endpoint in the growing landscape of data solutions."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Connectors")," are plugin components that bridge the gap between Flow\u2019s runtime and\nthe various endpoints from which you capture or materialize data.\nThey're packaged as Docker images, each encapsulating the details of working with\na particular kind of endpoint."),(0,i.kt)("p",null,"The connector then interacts with Flow's runtime through common and open protocols\nfor configuration, introspection of endpoint resources, and to coordinate the\nmovement of data into and out of the endpoint."),(0,i.kt)("p",null,"Crucially, this means Flow doesn't need to know about new types of endpoint ahead of time:\nso long as a connector is available Flow can work with the endpoint, and it's\nrelatively easy to build a connector yourself."),(0,i.kt)("h3",{id:"discovery"},"Discovery"),(0,i.kt)("p",null,"Connectors offer ",(0,i.kt)("strong",{parentName:"p"},"discovery")," APIs for understanding how a connector\nshould be configured, and what resources are available within an endpoint."),(0,i.kt)("p",null,"Flow works with connector APIs to provide a guided discovery workflow\nwhich makes it easy to configure the connector, and select from a menu\nof available endpoint resources you can capture."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/connectors"},"Learn more about endpoints and connectors")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"tests"},"Tests"),(0,i.kt)("p",null,"You use ",(0,i.kt)("strong",{parentName:"p"},"tests")," to verify the end-to-end behavior of your collections and derivations.\nA test is a sequence of ingestion or verification steps.\nIngestion steps ingest one or more document fixtures into a collection,\nand verification steps assert that the contents of another derived collection match a test expectation."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/tests"},"Learn more about tests")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"storage-mappings"},"Storage mappings"),(0,i.kt)("p",null,"Flow ",(0,i.kt)("a",{parentName:"p",href:"#collections"},"collections")," use cloud storage buckets for the durable storage of data.\nStorage mappings define how Flow maps your various collections into your storage buckets and prefixes."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/storage-mappings"},"Learn more about storage mappings")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"flowctl"},"flowctl"),(0,i.kt)("p",null,"flowctl is Flow's command-line interface.\nWith flowctl, developers can work directly on active catalogs and drafts created in the Flow webapp.\nThey can develop locally, test more flexibly, and collaboratively refine catalogs."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/concepts/flowctl"},"Learn more about flowctl")))}h.isMDXComponent=!0},982:function(e,t,a){t.Z=a.p+"assets/images/at-a-glance-da34673627d1be4959a23f38ad395e73.png"}}]);