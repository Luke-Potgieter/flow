"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[1066],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||l;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,r=new Array(l);r[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2360:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),o=n(6010);const l="tabItem_OmH5";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(l,r),hidden:n},t)}},9877:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(7462),o=n(7294),l=n(2389),r=n(7392),i=n(7094),s=n(2466),c=n(6010);const p="tabList_uSqn",u="tabItem_LplD";function m(e){var t,n,l;const{lazy:m,block:d,defaultValue:h,values:y,groupId:f,className:k}=e,b=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=y?y:b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),g=(0,r.l)(v,((e,t)=>e.value===t.value));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const w=null===h?h:null!=(t=null!=h?h:null==(n=b.find((e=>e.props.default)))?void 0:n.props.value)?t:null==(l=b[0])?void 0:l.props.value;if(null!==w&&!v.some((e=>e.value===w)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+v.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:N,setTabGroupChoices:T}=(0,i.U)(),[j,C]=(0,o.useState)(w),O=[],{blockElementScrollPositionUntilNextRender:x}=(0,s.o5)();if(null!=f){const e=N[f];null!=e&&e!==j&&v.some((t=>t.value===e))&&C(e)}const I=e=>{const t=e.currentTarget,n=O.indexOf(t),a=v[n].value;a!==j&&(x(t),C(a),null!=f&&T(f,a))},S=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=O.indexOf(e.currentTarget)+1;n=O[t]||O[0];break}case"ArrowLeft":{const t=O.indexOf(e.currentTarget)-1;n=O[t]||O[O.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,c.Z)("tabs-container",p)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":d},k)},v.map((e=>{let{value:t,label:n,attributes:l}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:j===t?0:-1,"aria-selected":j===t,key:t,ref:e=>O.push(e),onKeyDown:S,onFocus:I,onClick:I},l,{className:(0,c.Z)("tabs__item",u,null==l?void 0:l.className,{"tabs__item--active":j===t})}),null!=n?n:t)}))),m?(0,o.cloneElement)(b.filter((e=>e.props.value===j))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==j})))))}function d(e){const t=(0,l.Z)();return o.createElement(m,(0,a.Z)({key:String(t)},e))}},8227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var a=n(7462),o=(n(7294),n(3905)),l=n(9877),r=n(2360);const i={sidebar_position:2},s="Collections",c={unversionedId:"concepts/collections",id:"concepts/collections",title:"Collections",description:"Flow stores data in collections:",source:"@site/docs/concepts/collections.md",sourceDirName:"concepts",slug:"/concepts/collections",permalink:"/concepts/collections",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/collections.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Captures",permalink:"/concepts/captures"},next:{title:"Connectors",permalink:"/concepts/connectors"}},p={},u=[{value:"Specification",id:"specification",level:2},{value:"Schemas",id:"schemas",level:2},{value:"Keys",id:"keys",level:2},{value:"Schema restrictions",id:"schema-restrictions",level:3},{value:"Composite Keys",id:"composite-keys",level:3},{value:"Key behaviors",id:"key-behaviors",level:3},{value:"Empty keys",id:"empty-keys",level:3},{value:"Projections",id:"projections",level:2},{value:"Storage",id:"storage",level:2}],m={toc:u};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"collections"},"Collections"),(0,o.kt)("p",null,"Flow stores data in ",(0,o.kt)("strong",{parentName:"p"},"collections"),":\nreal-time data lakes of JSON documents.\nCollections may be added to by ",(0,o.kt)("a",{parentName:"p",href:"/concepts/captures"},"captures"),",\nor be ",(0,o.kt)("a",{parentName:"p",href:"/concepts/derivations"},"derived")," as a transformation\nof other source collections."),(0,o.kt)("p",null,"Every collection has a key and an associated ",(0,o.kt)("a",{parentName:"p",href:"#schemas"},"schema"),"\nthat its documents must validate against."),(0,o.kt)("h2",{id:"specification"},"Specification"),(0,o.kt)("p",null,"Collections are expressed within a Flow catalog specification:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'# A set of collections to include in the catalog.\n# Optional, type: object\ncollections:\n  # The unique name of the collection.\n  acmeCo/products/anvils:\n\n    # The schema of the collection, against which collection documents\n    # are validated. This may be an inline definition or a relative URL\n    # reference.\n    # Required, type: string (relative URL form) or object (inline form)\n    schema: anvils.schema.yaml\n\n    # The key of the collection, specified as JSON pointers of one or more\n    # locations within collection documents. If multiple fields are given,\n    # they act as a composite key, equivalent to a SQL table PRIMARY KEY\n    # with multiple table columns.\n    # Required, type: array\n    key: [/product/id]\n\n    # Projections and logical partitions for this collection.\n    # See the "Projections" concept page to learn more.\n    # Optional, type: object\n    projections:\n\n    # Derivation that builds this collection from others through transformations.\n    # See the "Derivations" concept page to learn more.\n    # Optional, type: object\n    derivation:\n')),(0,o.kt)("h2",{id:"schemas"},"Schemas"),(0,o.kt)("p",null,"Every Flow collection must declare a schema,\nand will never accept documents\nthat do not validate against the schema.\nThis helps ensure the quality of your data products\nand the reliability of your derivations and materializations.\nSchema specifications are flexible:\nyours could be exactingly strict, extremely permissive, or somewhere in between."),(0,o.kt)("p",null,"Schemas may either be declared inline, or provided as a reference to a file.\nReferences can also include JSON pointers as a URL fragment to name a specific schema of a larger schema document:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"Inline",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeCo/collection:\n    schema:\n      type: object\n      required: [id]\n      properties:\n        id: string\n    key: [/id]\n"))),(0,o.kt)(r.Z,{value:"File reference",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeCo/collection:\n    schema: ../path/to/collection.schema.yaml\n    key: [/id]\n"))),(0,o.kt)(r.Z,{value:"Reference with pointer",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeCo/collection:\n    schema: ../path/to/collection.schema.yaml#/definitions/mySchema\n    key: [/id]\n")))),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/concepts/schemas"},"Learn more about schemas")),(0,o.kt)("h2",{id:"keys"},"Keys"),(0,o.kt)("p",null,"Every Flow collection must declare a ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," which is used to group its documents.\nKeys are specified as an array of JSON pointers to document locations. For example:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"flow.yaml",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeCo/users:\n    schema: schema.yaml\n    key: [/userId]\n"))),(0,o.kt)(r.Z,{value:"schema.yaml",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"type: object\n  properties:\n    userId: {type: integer}\n    name: {type: string}\n  required: [userId, name]\n")))),(0,o.kt)("p",null,"Suppose the following JSON documents are captured into ",(0,o.kt)("inlineCode",{parentName:"p"},"acmeCo/users"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{"userId": 1, "name": "Will"}\n{"userId": 1, "name": "William"}\n{"userId": 1, "name": "Will"}\n')),(0,o.kt)("p",null,"As its key is ",(0,o.kt)("inlineCode",{parentName:"p"},"[/userId]"),", a materialization of the collection into a database table will reduce to a single row:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"userId | name\n1      | Will\n")),(0,o.kt)("p",null,"If its key were instead ",(0,o.kt)("inlineCode",{parentName:"p"},"[/name]"),", there would be two rows in the table:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"userId | name\n1      | Will\n1      | William\n")),(0,o.kt)("h3",{id:"schema-restrictions"},"Schema restrictions"),(0,o.kt)("p",null,"Keyed document locations may be of a limited set of allowed types:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"boolean")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"integer")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"string"))),(0,o.kt)("p",null,"Excluded types are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"array")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"object")),(0,o.kt)("li",{parentName:"ul"},"Fractional ",(0,o.kt)("inlineCode",{parentName:"li"},"number"))),(0,o.kt)("p",null,"Keyed fields also must always exist in collection documents.\nFlow performs static inference of the collection schema to verify the existence\nand types of all keyed document locations, and will report an error if the\nlocation could not exist, or could exist with the wrong type."),(0,o.kt)("p",null,"Flow itself doesn't mind if a keyed location could have multiple types,\nso long as they're each of the allowed types: an ",(0,o.kt)("inlineCode",{parentName:"p"},"integer")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," for example.\nSome materialization ",(0,o.kt)("a",{parentName:"p",href:"/concepts/connectors"},"connectors"),", however, may impose further type\nrestrictions as required by the endpoint.\nFor example, SQL databases do not support multiple types for a primary key."),(0,o.kt)("h3",{id:"composite-keys"},"Composite Keys"),(0,o.kt)("p",null,"A collection may have multiple locations which collectively form a composite key.\nThis can include locations within nested objects and arrays:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"flow.yaml",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeCo/compound-key:\n    schema: schema.yaml\n    key: [/foo/a, /foo/b, /foo/c/0, /foo/c/1]\n"))),(0,o.kt)(r.Z,{value:"schema.yaml",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"type: object\nrequired: [foo]\nproperties:\n  foo:\n    type: object\n    required: [a, b, c]\n    properties:\n      a: {type: integer}\n      b: {type: string}\n      c:\n        type: array\n        items: {type: boolean}\n        minItems: 2\n")))),(0,o.kt)("h3",{id:"key-behaviors"},"Key behaviors"),(0,o.kt)("p",null,'A collection key instructs Flow how documents of a collection are to be\nreduced, such as while being materialized to an endpoint.\nFlow also performs opportunistic local reductions over windows of documents\n(also called "combines") to improve its performance and reduce the volumes\nof data at each processing stage.'),(0,o.kt)("p",null,"An important subtlety is that the underlying storage of a collection\nwill potentially retain ",(0,o.kt)("em",{parentName:"p"},"many")," documents of a given key."),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"#keys"},"acmeCo/users example"),', each of the "Will" or "William" variants\nis likely represented in the collection\'s storage \u2014 so long as they didn\'t\narrive so closely together that they were locally combined by Flow.\nIf desired, a derivation could re-key the collection\non ',(0,o.kt)("inlineCode",{parentName:"p"},"[/userId, /name]")," to materialize the various ",(0,o.kt)("inlineCode",{parentName:"p"},"/name"),"s seen for a ",(0,o.kt)("inlineCode",{parentName:"p"},"/userId"),"."),(0,o.kt)("p",null,"This property makes keys less lossy than they might otherwise appear,\nand it is generally good practice to chose a key that reflects how\nyou wish to ",(0,o.kt)("em",{parentName:"p"},"query")," a collection, rather than an exhaustive key\nthat's certain to be unique for every document."),(0,o.kt)("h3",{id:"empty-keys"},"Empty keys"),(0,o.kt)("p",null,"When a catalog is automatically generated, there may not be an unambiguously correct key for all collections. This could occur, for example, when a SQL database doesn't have a primary key defined for some table."),(0,o.kt)("p",null,"In cases like this, the generated catalog will contain an empty collection key. However, every collection must have a non-empty key, so you'll need to manually edit the generated catalog and specify keys for those collections before using the catalog."),(0,o.kt)("h2",{id:"projections"},"Projections"),(0,o.kt)("p",null,"Projections are named locations within a collection document that may be used for\nlogical partitioning or directly exposed to databases into which collections are\nmaterialized."),(0,o.kt)("p",null,"Many projections are automatically inferred from the collection schema.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"projections")," stanza can be used to provide additional projections,\nand to declare logical partitions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  acmeCo/products/anvils:\n    schema: anvils.schema.yaml\n    key: [/product/id]\n\n    # Projections and logical partitions for this collection.\n    # Keys name the unique projection field, and values are its JSON Pointer\n    # location within the document and configure logical partitioning.\n    # Optional, type: object\n    projections:\n      # Short form: define a field "product_id" with document pointer /product/id.\n      product_id: "/product/id"\n\n      # Long form: define a field "metal" with document pointer /metal_type\n      # which is a logical partition of the collection.\n      metal:\n        location: "/metal_type"\n        partition: true\n\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/concepts/advanced/projections"},"Learn more about projections"),"."),(0,o.kt)("h2",{id:"storage"},"Storage"),(0,o.kt)("p",null,"Collections are real-time data lakes.\nHistorical documents of the collection\nare stored as an organized layout of\nregular JSON files in your cloud storage bucket.\nReads of that history are served by\ndirectly reading files from your bucket."),(0,o.kt)("p",null,"Your ",(0,o.kt)("a",{parentName:"p",href:"/concepts/storage-mappings"},"storage mappings"),"\ndetermine how Flow collections are mapped into\nyour cloud storage buckets."),(0,o.kt)("p",null,"Unlike a traditional data lake, however,\nit's very efficient to read collection documents as they are written.\nDerivations and materializations that source from a collection\nare notified of its new documents within milliseconds of their being published."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/concepts/advanced/journals"},"Learn more about journals, which provide storage for collections")))}d.isMDXComponent=!0}}]);