"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2665],{8215:function(e,t,a){var n=a(7294);t.Z=function(e){var t=e.children,a=e.hidden,o=e.className;return n.createElement("div",{role:"tabpanel",hidden:a,className:o},t)}},6396:function(e,t,a){a.d(t,{Z:function(){return m}});var n=a(7462),o=a(7294),r=a(2389),l=a(9443);var i=function(){var e=(0,o.useContext)(l.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=a(3616),c=a(6010),p="tabItem_vU9c";function u(e){var t,a,r,l=e.lazy,u=e.block,m=e.defaultValue,d=e.values,h=e.groupId,f=e.className,y=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=d?d:y.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),k=(0,s.lx)(v,(function(e,t){return e.value===t.value}));if(k.length>0)throw new Error('Docusaurus error: Duplicate values "'+k.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var w=null===m?m:null!=(t=null!=m?m:null==(a=y.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(r=y[0])?void 0:r.props.value;if(null!==w&&!v.some((function(e){return e.value===w})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=i(),b=g.tabGroupChoices,N=g.setTabGroupChoices,T=(0,o.useState)(w),C=T[0],S=T[1],x=[],I=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var E=b[h];null!=E&&E!==C&&v.some((function(e){return e.value===E}))&&S(E)}var Z=function(e){var t=e.currentTarget,a=x.indexOf(t),n=v[a].value;n!==C&&(I(t),S(n),null!=h&&N(h,n))},L=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n=x.indexOf(e.currentTarget)+1;a=x[n]||x[0];break;case"ArrowLeft":var o=x.indexOf(e.currentTarget)-1;a=x[o]||x[x.length-1]}null==(t=a)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":u},f)},v.map((function(e){var t=e.value,a=e.label,r=e.attributes;return o.createElement("li",(0,n.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return x.push(e)},onKeyDown:L,onFocus:Z,onClick:Z},r,{className:(0,c.Z)("tabs__item",p,null==r?void 0:r.className,{"tabs__item--active":C===t})}),null!=a?a:t)}))),l?(0,o.cloneElement)(y.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},y.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function m(e){var t=(0,r.Z)();return o.createElement(u,(0,n.Z)({key:String(t)},e))}},1504:function(e,t,a){var n=a(7294),o=a(7273);o.Z.initialize({startOnLoad:!0});t.Z=function(e){var t=e.chart;return(0,n.useEffect)((function(){o.Z.contentLoaded()}),[]),n.createElement("div",{className:"mermaid"},t)}},4379:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return p},contentTitle:function(){return u},metadata:function(){return m},toc:function(){return d},default:function(){return f}});var n=a(7462),o=a(3366),r=(a(7294),a(3905)),l=a(6396),i=a(8215),s=a(1504),c=["components"],p={},u="Imports",m={unversionedId:"concepts/import",id:"concepts/import",title:"Imports",description:"The import section is a list of partial or absolute URLs",source:"@site/docs/concepts/import.md",sourceDirName:"concepts",slug:"/concepts/import",permalink:"/concepts/import",editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/import.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"flowctl",permalink:"/concepts/flowctl"},next:{title:"Journals",permalink:"/concepts/journals"}},d=[{value:"Fetch Behavior",id:"fetch-behavior",children:[],level:2},{value:"Import Types",id:"import-types",children:[],level:2},{value:"JSON Schema <code>$ref</code>",id:"json-schema-ref",children:[],level:2},{value:"TypeScript Modules",id:"typescript-modules",children:[],level:2},{value:"NPM Dependencies",id:"npm-dependencies",children:[],level:2},{value:"Import Paths",id:"import-paths",children:[],level:2}],h={toc:d};function f(e){var t=e.components,a=(0,o.Z)(e,c);return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"imports"},"Imports"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," section is a list of partial or absolute URLs\nthat are always evaluated relative to the base directory of the current source file.\nFor example, these are possible imports within a collection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'# Suppose we\'re in file "/path/dir/flow.yaml"\nimport:\n  - sub/directory/flow.yaml        # Resolves to "file:///path/dir/sub/directory/flow.yaml".\n  - ../sibling/directory/flow.yaml # Resolves to "file:///path/sibling/directory/flow.yaml".\n  - https://example/path/flow.yaml # Uses the absolute url.\n')),(0,r.kt)("p",null,"The import rules are designed so that a collection doesn\u2019t have to do anything special\nin order to be imported by another,\nand ",(0,r.kt)("a",{parentName:"p",href:"/concepts/flowctl"},(0,r.kt)("inlineCode",{parentName:"a"},"flowctl"))," can even directly build remote sources:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Test an example from the flow-template repository.\n$ flowctl test --source https://raw.githubusercontent.com/estuary/flow-template/main/word-counts.flow.yaml\n")),(0,r.kt)("h2",{id:"fetch-behavior"},"Fetch Behavior"),(0,r.kt)("p",null,"Flow resolves, fetches, and validates all imports during the catalog build process,\nand then includes their fetched contents within the built catalog.\nThe built catalog is thus a self-contained snapshot of all resources\n",(0,r.kt)("em",{parentName:"p"},"as they were")," at the time the catalog was built."),(0,r.kt)("p",null,"An implication is that it's both safe and recommended to directly reference\nan authoritative source of a resource, such as a third-party JSON schema.\nIt will be fetched and verified only at catalog build time,\nand thereafter that fetched version will be used for execution,\nregardless of whether the authority URL itself later changes or errors."),(0,r.kt)("h2",{id:"import-types"},"Import Types"),(0,r.kt)("p",null,"Almost always, the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," stanza is used to import other Flow\ncatalog source files.\nThis is the default when given a string path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"import:\n - path/to/source/catalog.flow.yaml\n")),(0,r.kt)("p",null,"A long-form variant also accepts a content type of the imported resource:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"import:\n - url: path/to/source/catalog.flow.yaml\n   contentType: CATALOG\n")),(0,r.kt)("p",null,"Other permitted content types include ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON_SCHEMA")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TYPESCRIPT_MODULE"),",\nbut these are not typically used and are needed only for advanced use cases."),(0,r.kt)("h2",{id:"json-schema-ref"},"JSON Schema ",(0,r.kt)("inlineCode",{parentName:"h2"},"$ref")),(0,r.kt)("p",null,"JSON Schema has a ",(0,r.kt)("inlineCode",{parentName:"p"},"$ref")," keyword for referencing a schema which may\nbe contained in another file.\nSimilarly, various catalog source entities like collections also\naccept schema URLs.\nThese schema references are implicitly resolved\nand treated as an import of the built catalog.\nIt's not required to further list them in the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," stanza."),(0,r.kt)("p",null,"The one caveat are schemas which use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$id")," keyword\nat their root to define an alternative canonical URL.\nIn this case the schema must be referenced through its canonical URL,\nand then explicitly added as a catalog import\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"JSON_SCHEMA")," content type."),(0,r.kt)("h2",{id:"typescript-modules"},"TypeScript Modules"),(0,r.kt)("p",null,"You may declare entities in catalog source files that use\nTypeScript lambda definitions, such as derivations.\nThese lambdas are conventionally defined in TypeScript modules\nwhich accompany the specific catalog source.\nFlow looks for and automatically imports TypeScript modules\nwhich live alongside a Flow catalog source file."),(0,r.kt)("p",null,"Given a Flow catalog source at ",(0,r.kt)("inlineCode",{parentName:"p"},"/path/to/my.flow.yaml"),",\nFlow will automatically import the TypeScript module ",(0,r.kt)("inlineCode",{parentName:"p"},"/path/to/my.flow.ts"),".\nThis is conventionally the module which implements all TypeScript lambdas\nrelated to catalog entities defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"my.flow.yaml"),",\nand you do ",(0,r.kt)("strong",{parentName:"p"},"not")," need to also add ",(0,r.kt)("inlineCode",{parentName:"p"},"my.flow.ts")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," stanza."),(0,r.kt)("p",null,"However, Flow must know of all transitive TypeScript modules which\nare part of the catalog.\nIf additional modules are needed which live outside of these implicit\nmodules, they must be added as a catalog import\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"TYPESCRIPT_MODULE")," content type."),(0,r.kt)("h2",{id:"npm-dependencies"},"NPM Dependencies"),(0,r.kt)("p",null,"Your TypeScript modules may depend on other\n",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/"},"NPM packages"),",\nwhich can be be imported through the ",(0,r.kt)("inlineCode",{parentName:"p"},"npmDependencies"),"\nstanza of a Flow catalog source.\nFor example, ",(0,r.kt)("a",{parentName:"p",href:"https://momentjs.com/"},"moment")," is a common library\nfor working with times:"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"catalog.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'npmDependencies:\n  moment: "^2.24"\n\ncollections: { ... }\n'))),(0,r.kt)(i.Z,{value:"catalog.flow.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import * as moment from 'moment';\n\n// ... use `moment` as per usual.\n")))),(0,r.kt)("p",null,"Use any version string understood by ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),",\nwhich can include local packages, GitHub repository commits, and more.\nSee ",(0,r.kt)("a",{parentName:"p",href:"https://docs.npmjs.com/cli/v8/configuring-npm/package-json#dependencies"},"package.json documentation"),"."),(0,r.kt)("p",null,"During the catalog build process, Flow gathers NPM dependencies\nacross all catalog sources and patches them into the catalog's\nmanaged ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),".\nFlow organizes its generated TypeScript project structure\nfor a seamless editing experience out of the box with VSCode\nand other common editors."),(0,r.kt)("h2",{id:"import-paths"},"Import Paths"),(0,r.kt)("p",null,"If a catalog source file ",(0,r.kt)("inlineCode",{parentName:"p"},"foo.flow.yaml")," references a collection in ",(0,r.kt)("inlineCode",{parentName:"p"},"bar.flow.yaml"),",\nfor example as a target of a capture,\nthere must be an ",(0,r.kt)("em",{parentName:"p"},"import path")," where either ",(0,r.kt)("inlineCode",{parentName:"p"},"foo.flow.yaml"),"\nimports ",(0,r.kt)("inlineCode",{parentName:"p"},"bar.flow.yaml")," or vice versa."),(0,r.kt)("p",null,"Import paths can be direct:"),(0,r.kt)(s.Z,{chart:"\n\tgraph LR;\n\t\tfoo.flow.yaml--\x3ebar.flow.yaml;\n",mdxType:"Mermaid"}),(0,r.kt)("p",null,"Or they can be indirect:"),(0,r.kt)(s.Z,{chart:"\n\tgraph LR;\n\t\tbar.flow.yaml--\x3eother.flow.yaml;\n        other.flow.yaml--\x3efoo.flow.yaml;\n",mdxType:"Mermaid"}),(0,r.kt)("p",null,"However the sources must still have an import path\neven if referenced from a common parent.\nThe following would ",(0,r.kt)("strong",{parentName:"p"},"not")," work:"),(0,r.kt)(s.Z,{chart:"\n\tgraph LR;\n\t\tparent.flow.yaml--\x3efoo.flow.yaml;\n\t\tparent.flow.yaml--\x3ebar.flow.yaml;\n",mdxType:"Mermaid"}),(0,r.kt)("p",null,"These rules make your catalog sources more self contained\nand less brittle to refactoring and reorganization.\nConsider what might otherwise happen if ",(0,r.kt)("inlineCode",{parentName:"p"},"foo.flow.yaml"),"\nwere imported in another project without ",(0,r.kt)("inlineCode",{parentName:"p"},"bar.flow.yaml"),"."))}f.isMDXComponent=!0}}]);