(self.webpackChunksite=self.webpackChunksite||[]).push([[2536],{5162:(e,n,t)=>{"use strict";t.d(n,{Z:()=>i});var a=t(7294),r=t(4334);const s="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,i),hidden:t},n)}},4866:(e,n,t)=>{"use strict";t.d(n,{Z:()=>N});var a=t(7462),r=t(7294),s=t(4334),i=t(2466),o=t(6550),l=t(1980),c=t(7392),d=t(12);function u(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function m(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??u(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,o.k6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(a.location.search);n.set(s,e),a.replace({...a.location,search:n.toString()})}),[s,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,s=m(e),[i,o]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:s}))),[l,c]=h({queryString:t,groupId:a}),[u,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,s]=(0,d.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:a}),k=(()=>{const e=l??u;return p({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{k&&o(k)}),[k]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),f(e)}),[c,f,s]),tabValues:s}}var k=t(2389);const g="tabList__CuJ",b="tabItem_LNqP";function y(e){let{className:n,block:t,selectedValue:o,selectValue:l,tabValues:c}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.o5)(),m=e=>{const n=e.currentTarget,t=d.indexOf(n),a=c[t].value;a!==o&&(u(n),l(a))},p=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>d.push(e),onKeyDown:p,onClick:m},i,{className:(0,s.Z)("tabs__item",b,i?.className,{"tabs__item--active":o===n})}),t??n)})))}function v(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function w(e){const n=f(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",g)},r.createElement(y,(0,a.Z)({},e,n)),r.createElement(v,(0,a.Z)({},e,n)))}function N(e){const n=(0,k.Z)();return r.createElement(w,(0,a.Z)({key:String(n)},e))}},1504:(e,n,t)=>{"use strict";t.d(n,{Z:()=>s});var a=t(7294),r=t(2764);r.Z.initialize({startOnLoad:!0});const s=e=>{let{chart:n}=e;return(0,a.useEffect)((()=>{r.Z.contentLoaded()}),[]),a.createElement("div",{className:"mermaid"},n)}},9596:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var a=t(7462),r=(t(7294),t(3905)),s=t(4866),i=t(5162),o=t(1504);const l={sidebar_position:6},c="Derivations",d={unversionedId:"concepts/derivations",id:"concepts/derivations",title:"Derivations",description:"A derivation is a collection",source:"@site/docs/concepts/derivations.md",sourceDirName:"concepts",slug:"/concepts/derivations",permalink:"/concepts/derivations",draft:!1,editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/derivations.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Connectors",permalink:"/concepts/connectors"},next:{title:"Web application",permalink:"/concepts/web-app"}},u={},m=[{value:"Creating derivations",id:"creating-derivations",level:2},{value:"Specification",id:"specification",level:2},{value:"Background",id:"background",level:2},{value:"Transformations",id:"transformations",level:2},{value:"Sources",id:"sources",level:2},{value:"Shuffles",id:"shuffles",level:2},{value:"Registers",id:"registers",level:2},{value:"Lambdas",id:"lambdas",level:2},{value:"Publish lambdas",id:"publish-lambdas",level:3},{value:"Update lambdas",id:"update-lambdas",level:3},{value:"Creating TypeScript modules",id:"creating-typescript-modules",level:3},{value:"NPM dependencies",id:"npm-dependencies",level:3},{value:"Remote lambdas",id:"remote-lambdas",level:3},{value:"Processing order",id:"processing-order",level:2},{value:"Read delay",id:"read-delay",level:2},{value:"Read priority",id:"read-priority",level:2},{value:"Where to accumulate?",id:"where-to-accumulate",level:2},{value:"Accumulate in your database",id:"accumulate-in-your-database",level:3},{value:"Accumulate in registers",id:"accumulate-in-registers",level:3}],p={toc:m};function h(e){let{components:n,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"derivations"},"Derivations"),(0,r.kt)("p",null,"A derivation is a ",(0,r.kt)("a",{parentName:"p",href:"../#collections"},"collection"),"\nthat results from transformations applied to one or more other collections."),(0,r.kt)("p",null,"Derivations derive data continuously,\nreflecting updates to the source collections as they happen."),(0,r.kt)("p",null,"A derivation has two main components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The new collection, which stores the derived data."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("a",{parentName:"li",href:"../#tasks"},"catalog task"),", which applies the transformations to source documents as they become available.")),(0,r.kt)("p",null,"The derivation task is defined by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"transformations")," it applies"),(0,r.kt)("li",{parentName:"ul"},"Its ",(0,r.kt)("strong",{parentName:"li"},"register"),", which serves as its internal memory"),(0,r.kt)("li",{parentName:"ul"},"In many cases, ",(0,r.kt)("strong",{parentName:"li"},"lambdas"),", functions defined in accompanying TypeScript modules\nthat allow more complex transformations.")),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(7918).Z,width:"960",height:"540"})),(0,r.kt)("h2",{id:"creating-derivations"},"Creating derivations"),(0,r.kt)("p",null,"You can create a derivation in your local development environment using flowctl."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/concepts/flowctl#working-with-catalog-drafts"},(0,r.kt)("inlineCode",{parentName:"a"},"flowctl draft")," to begin work with a draft"),",\nand manually add ",(0,r.kt)("a",{parentName:"p",href:"#specification"},"a derivation to the Flow specification file"),"."),(0,r.kt)("p",null,"If necessary, ",(0,r.kt)("a",{parentName:"p",href:"#creating-typescript-modules"},"generate a typescript file")," and define lambda functions there."),(0,r.kt)("h2",{id:"specification"},"Specification"),(0,r.kt)("p",null,"A derivation is specified as a regular collection with an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"derivation")," stanza:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  # The unique name of the derivation.\n  acmeCo/my/derivation:\n    schema: my-schema.yaml\n    key: [/key]\n\n    # Presence of a `derivation` stanza makes this collection a derivation.\n    # Type: object\n    derivation:\n\n      # Register definition of the derivation.\n      # If not provided, registers have an unconstrained schema\n      # and initialize to the `null` value.\n      # Optional, type: object\n      register:\n\n        # JSON Schema of register documents. As with collection schemas,\n        # this is either an inline definition or a relative URL reference.\n        # Required, type: string (relative URL form) or object (inline form)\n        schema:\n          type: integer\n\n        # Initial value taken by a register which has never been updated before.\n        # Optional, default: null\n        initial: 0\n\n      # TypeScript module that implements any lambda functions invoked by this derivation.\n      # Optional, type: object\n      typescript:\n\n        # TypeScript module implementing this derivation.\n        # Module is either a relative URL of a TypeScript module file (recommended),\n        # or an inline representation of a TypeScript module.\n        # The file specified will be created when you run `flowctl typescript generate`\n        module: acmeModule.ts\n\n        # NPM package dependencies of the module\n        # Version strings can take any form understood by NPM.\n        # See https://docs.npmjs.com/files/package.json#dependencies\n        npmDependencies: {}\n\n      # Transformations of the derivation,\n      # specified as a map of named transformations.\n      transform:\n\n        # Unique name of the transformation, containing only Unicode\n        # Letters and Numbers (no spaces or punctuation).\n        myTransformName:\n\n          # Source collection read by this transformation.\n          # Required, type: object\n          source:\n            # Name of the collection to be read.\n            # Required.\n            name: acmeCo/my/source/collection\n            # Partition selector of the source collection.\n            # Optional. Default is to read all partitions.\n            partitions: {}\n\n          # Delay applied to sourced documents before being processed\n          # by this transformation.\n          # Default: No delay, pattern: ^\\\\d+(s|m|h)$\n          readDelay: "48h"\n\n          # Shuffle determines the key by which source documents are\n          # shuffled (mapped) to a register.\n          # Optional, type: object.\n          # If not provided, documents are shuffled on the source collection key.\n          shuffle:\n            # Key is a composite key which is extracted from documents\n            # of the source.\n            key: [/shuffle/key/one, /shuffle/key/two]\n\n          # Update lambda of the transformation.\n          # Optional, type: object\n          update: {lambda: typescript}\n\n          # Publish lambda of the transformation.\n          # Optional, type: object\n          publish: {lambda: typescript}\n\n          # Priority applied to processing documents of this transformation\n          # relative to other transformations of the derivation.\n          # Default: 0, integer >= 0\n          priority: 0\n\n')),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,"The following sections will refer to the following common example\nto illustrate concepts."),(0,r.kt)("p",null,"Suppose you have an application through which users send one another\nsome amount of currency, like in-game tokens or dollars or digital kittens:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"transfers.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.flow.yaml",file:"./bank/transfers.flow.yaml"},"collections:\n  # Collection of \ud83d\udcb2 transfers between accounts:\n  #   {id: 123, sender: alice, recipient: bob, amount: 32.50}\n  acmeBank/transfers:\n    schema: transfers.schema.yaml\n    key: [/id]\n"))),(0,r.kt)(i.Z,{value:"transfers.schema.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.schema.yaml",file:"./bank/transfers.schema.yaml"},"type: object\nproperties:\n  id: { type: integer }\n  sender: { type: string }\n  recipient: { type: string }\n  amount: { type: number }\nrequired: [id, sender, recipient, amount]\n")))),(0,r.kt)("p",null,"There are many views over this data that you might require,\nsuch as summaries of sender or receiver activity,\nor current account balances within your application."),(0,r.kt)("h2",{id:"transformations"},"Transformations"),(0,r.kt)("p",null,"A transformation binds a ",(0,r.kt)("a",{parentName:"p",href:"#sources"},"source")," collection to a derivation.\nAs documents of the source collection arrive,\nthe transformation processes the document\nto ",(0,r.kt)("a",{parentName:"p",href:"#publish-lambdas"},"publish")," new documents,\n",(0,r.kt)("a",{parentName:"p",href:"#update-lambdas"},"update")," a\n",(0,r.kt)("a",{parentName:"p",href:"#registers"},"register"),",\nor both."),(0,r.kt)("p",null,"Read source documents are ",(0,r.kt)("a",{parentName:"p",href:"#shuffles"},"shuffled")," on a ",(0,r.kt)("strong",{parentName:"p"},"shuffle key")," to\nco-locate the processing of documents that have equal shuffle keys.\nThe transformation then processes documents by invoking ",(0,r.kt)("strong",{parentName:"p"},"lambdas"),":\nuser-defined functions that accept documents as arguments\nand return documents in response."),(0,r.kt)("p",null,"A derivation may have many transformations,\nand each transformation has a long-lived and stable name.\nEach transformation independently reads documents from its\nsource collection and tracks its own read progress.\nMore than one transformation can read from the same source collection,\nand transformations may also source from their own derivation,\nenabling cyclic data-flows and graph algorithms."),(0,r.kt)("p",null,"Transformations may be added to or removed from a derivation at any time.\nThis makes it possible to, for example, add a new collection into an\nexisting multi-way join, or gracefully migrate to a new source\ncollection without incurring downtime.\nHowever, renaming a running transformation is not possible.\nIf attempted, the old transformation is dropped and\na new transformation under the new name is created,\nwhich begins reading its source collection all over again."),(0,r.kt)(o.Z,{chart:"\n\tgraph LR;\n    d[Derivation];\n    t[Transformation];\n    r[Registers];\n    p[Publish \u03bb];\n    u[Update \u03bb];\n    c[Sourced Collection];\n    d-- has many --\x3et;\n    t-- reads from --\x3ec;\n    t-- invokes --\x3eu;\n    t-- invokes --\x3ep;\n    u-- updates --\x3er;\n    r-- reads --\x3ep;\n    d-- indexes --\x3er;\n",mdxType:"Mermaid"}),(0,r.kt)("h2",{id:"sources"},"Sources"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"source")," of a transformation is a collection.\nAs documents are published into the source collection,\nthey are continuously read and processed by the transformation."),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/concepts/advanced/projections#partition-selectors"},"partition selector")," may be provided\nto process only a subset of the source collection's logical partitions.\nSelectors are efficient: only partitions that match the selector are read,\nand Flow can cheaply skip over partitions that don't."),(0,r.kt)("p",null,"Derivations re-validate their source documents against\nthe source collection's schema as they are read.\nThis is because collection schemas may evolve over time,\nand could have inadvertently become incompatible with\nhistorical documents of the source collection.\nUpon a schema error, the derivation will pause and\ngive you an opportunity to correct the problem."),(0,r.kt)("p",null,"You may also provide an alternative ",(0,r.kt)("strong",{parentName:"p"},"source schema"),".\nSource schemas aide in processing third-party sources\nof data that you don't control,\nwhich can have unexpected schema changes without notice.\nYou may want to capture this data\nwith a minimal and very permissive schema.\nThen, a derivation can apply a significantly stricter source schema,\nwhich verifies your current expectations of what the data ",(0,r.kt)("em",{parentName:"p"},"should")," be.\nIf those expectations turn out to be wrong,\nlittle harm is done:\nyour derivation is paused but the capture continues to run.\nYou must simply update your transformations\nto account for the upstream changes and then continue without any data loss."),(0,r.kt)("h2",{id:"shuffles"},"Shuffles"),(0,r.kt)("p",null,"As each source document is read, it's shuffled \u2014 or equivalently, mapped \u2014\non an extracted key."),(0,r.kt)("p",null,"If you're familiar with data shuffles in tools like MapReduce, Apache Spark,\nor Flink, the concept is very similar.\nFlow catalog tasks scale to run across many machines at the same time,\nwhere each machine processes a subset of source documents.\nShuffles let Flow know how to group documents so that they're co-located,\nwhich can increase processing efficiency and reduce data volumes.\nThey are also used to map source documents to ",(0,r.kt)("a",{parentName:"p",href:"#registers"},"registers"),"."),(0,r.kt)(o.Z,{chart:"\n\tgraph LR;\n    subgraph s1 [Source Partitions]\n      p1>acmeBank/transfers/part-1];\n      p2>acmeBank/transfers/part-2];\n    end\n    subgraph s2 [Derivation Task Shards]\n      t1([task/shard-1]);\n      t2([task/shard-2]);\n    end\n    p1-- sender: alice --\x3et1;\n    p1-- sender: bob --\x3et2;\n    p2-- sender: alice --\x3et1;\n    p2-- sender: bob --\x3et2;\n",mdxType:"Mermaid"}),(0,r.kt)("p",null,"If you don't provide a shuffle key,\nFlow will shuffle on the source collection key,\nwhich is typically what you want."),(0,r.kt)("p",null,"If a derivation has more than one transformation,\nthe shuffle keys of all transformations must align with one another\nin terms of the extracted key types (string or integer)\nas well as the number of components in a composite key.\nFor example, one transformation couldn't shuffle transfers on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/id]"),"\nwhile another shuffles on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]"),", because ",(0,r.kt)("inlineCode",{parentName:"p"},"sender")," is a string and\n",(0,r.kt)("inlineCode",{parentName:"p"},"id")," an integer.\nSimilarly mixing a shuffle of ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]")," alongside ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]"),"\nis prohibited because the keys have different numbers of components.\nHowever, one transformation ",(0,r.kt)("em",{parentName:"p"},"can")," shuffle on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]"),"\nwhile another shuffles on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/recipient]"),",\nas in the examples below."),(0,r.kt)("h2",{id:"registers"},"Registers"),(0,r.kt)("p",null,"Registers are the internal ",(0,r.kt)("em",{parentName:"p"},"memory")," of a derivation.\nThey are a building block that enable derivations to tackle advanced stateful\nstreaming computations like multi-way joins, windowing, and transaction processing.\nAs we've already seen, not all derivations require registers,\nbut they are essential for a variety of important use cases."),(0,r.kt)("p",null,"Each register is a document with a user-defined\n",(0,r.kt)("a",{parentName:"p",href:"/concepts/schemas"},"schema"),".\nRegisters are keyed, and every derivation maintains an index of keys\nand their corresponding register documents.\nEvery source document is mapped to a specific register document\nthrough its extracted ",(0,r.kt)("a",{parentName:"p",href:"#shuffles"},"shuffle key"),"."),(0,r.kt)("p",null,"For example, when shuffling ",(0,r.kt)("inlineCode",{parentName:"p"},"acmeBank/transfers")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender]")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"[/recipient]"),',\neach account ("alice", "bob", or "carol") is allocated its own register.\nYou might use that register to track a current account balance\ngiven the received inflows and sent outflows of each account.'),(0,r.kt)("p",null,"If you instead shuffle on ",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]"),', each\npair of accounts ("alice -> bob", "alice -> carol", "bob -> carol")\nis allocated a register.'),(0,r.kt)("p",null,"Transformations of a derivation may have different shuffle keys,\nbut the number of key components and their JSON types must agree.\nTwo transformations could map on ","[/sender]"," and ","[/recipient]",",\nbut not ","[/sender]"," and ","[/recipient, /sender]","."),(0,r.kt)("p",null,"Registers are best suited for relatively small,\nfast-changing documents that are shared within and across\nthe transformations of a derivation.\nThe number of registers indexed within a derivation may be very large,\nand if a register has never before been used,\nit starts with a user-defined initial value.\nFrom there, registers may be modified through an ",(0,r.kt)("strong",{parentName:"p"},"update lambda"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Under the hood, registers are backed by replicated,\nembedded RocksDB instances, which co-locate\nwith the lambda execution contexts that Flow manages.\nAs contexts are assigned and re-assigned,\ntheir register databases travel with them."),(0,r.kt)("p",{parentName:"admonition"},"If any single RocksDB instance becomes too large,\nFlow is able to perform an online ",(0,r.kt)("strong",{parentName:"p"},"split"),",\nwhich subdivides its contents into two new databases\n\u2014 and paired execution contexts \u2014 which are re-assigned to other machines.")),(0,r.kt)("h2",{id:"lambdas"},"Lambdas"),(0,r.kt)("p",null,"Lambdas are user-defined functions that are invoked by derivations.\nThey accept documents as arguments\nand return transformed documents in response.\nLambdas can be used to update registers, publish documents into a derived collection,\nor compute a non-trivial shuffle key of a document."),(0,r.kt)("admonition",{title:"Beta",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ability for lambdas to compute a document's shuffle key is coming soon.")),(0,r.kt)("p",null,"Flow supports TypeScript lambdas, which you define in an accompanying TypeScript module\nand reference in a derivation's ",(0,r.kt)("inlineCode",{parentName:"p"},"typescript")," stanzas.\nSee the ",(0,r.kt)("a",{parentName:"p",href:"#specification"},"derivation specification")," and ",(0,r.kt)("a",{parentName:"p",href:"#creating-typescript-modules"},"Creating TypeScript modules"),' for more details on how to get started.\nTypeScript lambdas are "serverless"; Flow manages the execution and scaling of your Lambda on your behalf.'),(0,r.kt)("p",null,"Alternatively, Flow also supports ",(0,r.kt)("a",{parentName:"p",href:"#remote-lambdas"},"remote lambdas"),", which invoke an HTTP endpoint you provide,\nsuch as an AWS Lambda or Google Cloud Run function."),(0,r.kt)("p",null,"In terms of the MapReduce functional programming paradigm,\nFlow lambdas are mappers,\nwhich map documents into new user-defined shapes.\nReductions are implemented by Flow\nusing the ",(0,r.kt)("a",{parentName:"p",href:"/concepts/schemas#reduce-annotations"},"reduction annotations")," of your collection schemas."),(0,r.kt)("h3",{id:"publish-lambdas"},"Publish lambdas"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"publish")," lambda publishes documents into the derived collection."),(0,r.kt)("p",null,"To illustrate first with an example,\nsuppose you must know the last transfer\nfrom each sender that was over $100:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"last-large-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send.flow.yaml",file:"./bank/last-large-send.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  examples/acmeBank/last-large-send:\n    schema: transfers.schema.yaml\n    key: [/sender]\n\n    derivation:\n      typescript:\n        module: last-large-send.ts\n      transform:\n        fromTransfers:\n          source:\n            name: examples/acmeBank/transfers\n          publish:\n            lambda: typescript\n"))),(0,r.kt)(i.Z,{value:"last-large-send.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/last-large-send.ts",file:"./bank/last-large-send.ts"},"import { IDerivation, Document, Register, FromTransfersSource } from 'flow/examples/acmeBank/last-large-send';\n\n// Implementation for derivation last-large-send.flow.yaml#/collections/examples~1acmeBank~1last-large-send/derivation.\nexport class Derivation implements IDerivation {\n    fromTransfersPublish(\n        source: FromTransfersSource,\n        _register: Register,\n        _previous: Register,\n    ): Document[] {\n        if (source.amount > 100) {\n            return [source]; // This is a large send.\n        }\n        return []; // Filter this `source` document.\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"last-large-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send-test.flow.yaml",file:"./bank/last-large-send-test.flow.yaml"},"import:\n  - last-large-send.flow.yaml\n\ntests:\n  examples/acmeBank/tests/last-large-send:\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Initial set of transfers amongst users\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 2, sender: bob, recipient: alice, amount: 10.22 }\n          - { id: 3, sender: carol, recipient: bob, amount: 327.00 }\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Alice and Carol later send additional transfers.\n        documents:\n          - { id: 4, sender: alice, recipient: carol, amount: 32.50 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n    - verify:\n        collection: examples/acmeBank/last-large-send\n        description: |\n          Expect the most-recent of Carol's large transfers is tracked,\n          along with Alice's only large transfer.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n")))),(0,r.kt)("p",null,"This transformation defines a TypeScript ",(0,r.kt)("strong",{parentName:"p"},"publish")," lambda,\nwhich is implemented in an accompanying TypeScript module.\nThe lambda is invoked as each source transfer document arrives.\nIt is given the ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," document,\nand also includes the a ",(0,r.kt)("inlineCode",{parentName:"p"},"_register")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_previous")," register, which are not used here.\nThe lambda outputs zero or more documents,\neach of which must conform to the derivation's schema."),(0,r.kt)("p",null,"As this derivation's collection is keyed on ",(0,r.kt)("inlineCode",{parentName:"p"},"/sender"),",\nthe last published document (the last large transfer) of each sender is retained.\nIf it were instead keyed on ",(0,r.kt)("inlineCode",{parentName:"p"},"/id"),",\nthen ",(0,r.kt)("em",{parentName:"p"},"all")," transfers with large amounts would be retained.\nIn SQL terms, the collection key acts as a GROUP BY."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Derivation collection schemas may have\n",(0,r.kt)("a",{parentName:"p",href:"/concepts/schemas#reductions"},"reduction")," annotations,\nand publish lambdas can be combined with reductions in interesting ways."),(0,r.kt)("p",null,"You may be familiar with ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduce")," functions\nbuilt into languages like\n",(0,r.kt)("a",{parentName:"p",href:"https://book.pythontips.com/en/latest/map_filter.html"},"Python"),",\n",(0,r.kt)("a",{parentName:"p",href:"https://www.freecodecamp.org/news/javascript-map-reduce-and-filter-explained-with-examples/"},"JavaScript"),';\nand many others,\nor have used tools like MapReduce or Spark.\nIn functional terms, lambdas you write within Flow are "mappers,"\nand reductions are always done\nby the Flow runtime using your schema annotations.'),(0,r.kt)("p",null,"Suppose you need to know the running\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Double-entry_bookkeeping"},"account balances"),"\nof your users given all of their transfers thus far.\nTackle this by ",(0,r.kt)("em",{parentName:"p"},"reducing")," the final account balance\nfor each user from all of the credit and debit amounts of their transfers:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"balances.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/balances.flow.yaml",file:"./bank/balances.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  examples/acmeBank/balances:\n    schema:\n      type: object\n      required: [user]\n      reduce: { strategy: merge }\n      properties:\n        user: { type: string }\n        balance:\n          type: number\n          reduce: { strategy: sum }\n    key: [/user]\n\n    derivation:\n      typescript:\n        module: balances.ts\n      transform:\n        fromTransfers:\n          source:\n            name: examples/acmeBank/transfers\n          publish:\n            lambda: typescript\n"))),(0,r.kt)(i.Z,{value:"balances.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/balances.ts",file:"./bank/balances.ts"},"import { IDerivation, Document, Register, FromTransfersSource } from 'flow/examples/acmeBank/balances';\n\n// Implementation for derivation balances.flow.yaml#/collections/examples~1acmeBank~1balances/derivation.\nexport class Derivation implements IDerivation {\n    fromTransfersPublish(\n        source: FromTransfersSource,\n        _register: Register,\n        _previous: Register,\n    ): Document[] {\n        return [\n            // Debit the sender.\n            { user: source.sender, balance: -source.amount },\n            // Credit the recipient.\n            { user: source.recipient, balance: source.amount },\n        ];\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"balances-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/balances-test.flow.yaml",file:"./bank/balances-test.flow.yaml"},"import:\n  - balances.flow.yaml\n\ntests:\n  examples/acmeBank/tests/balances:\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Initial deposits into user accounts.\n        documents:\n          - { id: 1, sender: CREDIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: CREDIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: CREDIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Transfers between users, and a withdraw.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 20 }\n          - { id: 5, sender: bob, recipient: carol, amount: 40 }\n          - { id: 6, sender: carol, recipient: alice, amount: 90 }\n          - { id: 7, sender: bob, recipient: CREDIT, amount: 40 }\n\n    - verify:\n        collection: examples/acmeBank/balances\n        description: Verify expected balances.\n        documents:\n          - { user: CREDIT, balance: -260 }\n          - { user: alice, balance: 170 }\n          - { user: bob, balance: 40 }\n          - { user: carol, balance: 50 }\n")))),(0,r.kt)("h3",{id:"update-lambdas"},"Update lambdas"),(0,r.kt)("p",null,"An ",(0,r.kt)("strong",{parentName:"p"},"update")," lambda transforms a source document\ninto an update of the source document's register."),(0,r.kt)("p",null,"To again illustrate through an example,\nsuppose your compliance department wants you to flag\nthe first transfer a sender sends to a new recipient.\nYou achieve this by shuffling on pairs of\n",(0,r.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]")," and using a register\nto track whether this account pair has been seen before:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"first-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send.flow.yaml",file:"./bank/first-send.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  examples/acmeBank/first-send:\n    schema: transfers.schema.yaml\n    key: [/id]\n\n    derivation:\n      # We'll store a `true/false` boolean in our register documents,\n      # which is initially `false` and becomes `true` after the first transfer.\n      register:\n        schema: { type: boolean }\n        initial: false\n\n      typescript:\n        module: first-send.ts\n\n      transform:\n        fromTransfers:\n          source:\n            name: examples/acmeBank/transfers\n          # Shuffle so that each account pair\n          # is allocated its own register.\n          shuffle:\n            key: [/sender, /recipient]\n          update:\n            lambda: typescript\n          publish:\n            lambda: typescript\n"))),(0,r.kt)(i.Z,{value:"first-send.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/first-send.ts",file:"./bank/first-send.ts"},"import { IDerivation, Document, Register, FromTransfersSource } from 'flow/examples/acmeBank/first-send';\n\n// Implementation for derivation first-send.flow.yaml#/collections/examples~1acmeBank~1first-send/derivation.\nexport class Derivation implements IDerivation {\n    fromTransfersUpdate(\n        _source: FromTransfersSource,\n    ): Register[] {\n        return [true]; // Toggle the register from `false` => `true`.\n    }\n    fromTransfersPublish(\n        source: FromTransfersSource,\n        _register: Register,\n        previous: Register,\n    ): Document[] {\n        // If the register was previously false, than this is the first\n        // transfer for this account pair.\n        if (!previous) {\n            return [source];\n        }\n        return []; // Not the first transfer.\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"first-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send-test.flow.yaml",file:"./bank/first-send-test.flow.yaml"},"import:\n  - first-send.flow.yaml\n\ntests:\n  examples/acmeBank/tests/first-send:\n    - ingest:\n        collection: examples/acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 2, sender: alice, recipient: bob, amount: 13.40 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n          - { id: 5, sender: carol, recipient: alice, amount: 2.36 }\n          - { id: 6, sender: alice, recipient: carol, amount: 7.13 }\n\n    - verify:\n        collection: examples/acmeBank/first-send\n        description: |\n          Expect we filtered to the first interaction of each account pair.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n")))),(0,r.kt)("p",null,"This transformation uses both a publish and an ",(0,r.kt)("strong",{parentName:"p"},"update")," lambda,\nimplemented in an accompanying TypeScript module.\nThe update lambda is invoked first for each ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," document,\nand it returns zero or more documents,\nwhich each must conform to the derivation's register schema\n(in this case, a simple boolean)."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"publish")," lambda is invoked next, and is given the ",(0,r.kt)("inlineCode",{parentName:"p"},"source"),"\ndocument as well as the ",(0,r.kt)("em",{parentName:"p"},"before")," (",(0,r.kt)("inlineCode",{parentName:"p"},"previous"),") and ",(0,r.kt)("em",{parentName:"p"},"after")," (",(0,r.kt)("inlineCode",{parentName:"p"},"_register"),")\nvalues of the updated register.\nIn this case, we don't need the ",(0,r.kt)("em",{parentName:"p"},"after")," value:\nour update lambda implementation implies that it's always ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".\nThe ",(0,r.kt)("em",{parentName:"p"},"before")," value, however,\ntells us whether this was the very first update of this register,\nand by implication was the first transfer for this pair of accounts."),(0,r.kt)(o.Z,{chart:'\n  sequenceDiagram\n    autonumber\n    Derivation->>Update \u03bb: update({sender: alice, recipient: bob})?\n    Update \u03bb--\x3e>Derivation: return "true"\n    Derivation->>Registers: lookup(key = [alice, bob])?\n    Registers--\x3e>Derivation: not found, initialize as "false"\n    Derivation--\x3e>Derivation: Register: "false" => "true"\n    Derivation-)Registers: store(key = [alice, bob], value = "true")\n    Derivation->>Publish \u03bb: publish({sender: alice, recipient: bob}, register = "true", previous = "false")?\n    Publish \u03bb--\x3e>Derivation: return {sender: alice, recipient: bob}\n',mdxType:"Mermaid"}),(0,r.kt)("admonition",{title:"FAQ",type:"info"},(0,r.kt)("blockquote",{parentName:"admonition"},(0,r.kt)("p",{parentName:"blockquote"},"Why not have one lambda that can return\na register update ",(0,r.kt)("em",{parentName:"p"},"and")," derived documents?")),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Performance."),"\n",(0,r.kt)("em",{parentName:"p"},"Update")," and ",(0,r.kt)("em",{parentName:"p"},"publish")," are designed to be\nparallelized and pipelined over many source documents simultaneously,\nwhile still giving the appearance and correctness of lambdas\nare invoked in strict serial order.\nNotice that (1) above doesn't depend on actually knowing the register\nvalue, which doesn't happen until (4).\nMany calls like (1) can also happen in parallel,\nso long as their applications to the register value (5)\nhappen in the correct order.\nIn comparison, a single-lambda design\nwould require Flow to await each invocation\nbefore it can begin the next.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Register schemas may also have\n",(0,r.kt)("a",{parentName:"p",href:"/concepts/schemas#reductions"},"reduction")," annotations,\nand documents returned by update lambdas\nare ",(0,r.kt)("em",{parentName:"p"},"reduced")," into the current register value."),(0,r.kt)("p",null,"The compliance department reached out again,\nand this time they need you to identify transfers where\nthe sender's account had insufficient funds."),(0,r.kt)("p",null,"You manage this by tracking\nthe running credits and debits of each account in a register.\nThen, you enrich each transfer with the account's current balance\nand whether the account was overdrawn:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"flagged-transfers.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/flagged-transfers.flow.yaml",file:"./bank/flagged-transfers.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  examples/acmeBank/flagged-transfers:\n    schema:\n      # Extend transfer schema with `balance` and `overdrawn` fields.\n      $ref: transfers.schema.yaml\n      required: [balance, overdrawn]\n      properties:\n        balance: { type: number }\n        overdrawn: { type: boolean }\n    key: [/id]\n\n    projections:\n      # Logically partition on transfers which are flagged as overdrawn.\n      overdrawn:\n        location: /overdrawn\n        partition: true\n\n    derivation:\n      # Registers track the current balance of each account.\n      register:\n        schema:\n          type: number\n          reduce: { strategy: sum }\n        initial: 0\n\n      typescript:\n        module: flagged-transfers.ts\n\n      transform:\n        fromTransferSender:\n          source: { name: examples/acmeBank/transfers }\n          shuffle: { key: [/sender] }\n          # Debit the sender's register balance.\n          update: { lambda: typescript }\n          # Publish transfer enriched with current sender balance.\n          publish: { lambda: typescript }\n\n        fromTransferRecipient:\n          source: { name: examples/acmeBank/transfers }\n          shuffle: { key: [/recipient] }\n          # Credit the recipient's register balance.\n          update: { lambda: typescript }\n"))),(0,r.kt)(i.Z,{value:"flagged-transfers.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/flagged-transfers.ts",file:"./bank/flagged-transfers.ts"},"import { IDerivation, Document, Register, FromTransferRecipientSource, FromTransferSenderSource } from 'flow/examples/acmeBank/flagged-transfers';\n\n// Implementation for derivation flagged-transfers.flow.yaml#/collections/examples~1acmeBank~1flagged-transfers/derivation.\nexport class Derivation implements IDerivation {\n    fromTransferRecipientUpdate(\n        source: FromTransferRecipientSource,\n    ): Register[] {\n        return [source.amount]; // Credit recipient.\n    }\n    fromTransferSenderUpdate(\n        source: FromTransferSenderSource,\n    ): Register[] {\n        return [-source.amount]; // Debit sender.\n    }\n    fromTransferSenderPublish(\n        source: FromTransferSenderSource,\n        balance: Register,\n        _previous: Register,\n    ): Document[] {\n        if (balance > 0 || source.sender == 'CREDIT') {\n            return [{ ...source, balance: balance, overdrawn: false }];\n        } else {\n            return [{ ...source, balance: balance, overdrawn: true }];\n        }\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"flagged-transfers-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/flagged-transfers-test.flow.yaml",file:"./bank/flagged-transfers-test.flow.yaml"},"import:\n  - flagged-transfers.flow.yaml\n\ntests:\n  examples/acmeBank/tests/flagged-transfers:\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Initial deposits.\n        documents:\n          - { id: 1, sender: CREDIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: CREDIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: CREDIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: Transfers between users.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 50 }\n          - { id: 5, sender: bob, recipient: carol, amount: 75 }\n\n    - ingest:\n        collection: examples/acmeBank/transfers\n        description: |\n          Further transfers between users, with one being an overdraft.\n        documents:\n          - { id: 6, sender: alice, recipient: carol, amount: 75 }\n          - { id: 7, sender: carol, recipient: bob, amount: 175 }\n\n    - verify:\n        collection: examples/acmeBank/flagged-transfers\n        description: |\n          Expect transfer #6 was flagged as being overdrawn.\n        partitions:\n          include:\n            overdrawn: [true]\n        documents:\n          - {\n              id: 6,\n              amount: 75,\n              balance: -25,\n              overdrawn: true,\n              recipient: carol,\n              sender: alice,\n            }\n")))),(0,r.kt)("p",null,"Source transfers are read twice.\nThe first read shuffles on ",(0,r.kt)("inlineCode",{parentName:"p"},"/recipient"),"\nto track account credits,\nand the second shuffles on ",(0,r.kt)("inlineCode",{parentName:"p"},"/sender"),"\nto track account debits and to publish enriched transfer events.\nUpdate lambdas return the amount of credit or debit,\nand these amounts are summed\ninto a derivation register keyed on the account."),(0,r.kt)(o.Z,{chart:"\n  sequenceDiagram\n    autonumber\n    Derivation->>Registers: lookup(key = alice)?\n    Registers--\x3e>Derivation: not found, initialize as 0\n    Derivation->>Update \u03bb: update({recipient: alice, amount: 50, ...})?\n    Update \u03bb--\x3e>Derivation: return +50\n    Derivation->>Update \u03bb: update({sender: alice, amount: 75, ...})?\n    Update \u03bb--\x3e>Derivation: return -75\n    Derivation--\x3e>Derivation: Register: 0 + 50 => 50\n    Derivation--\x3e>Derivation: Register: 50 - 75 => -25\n    Derivation->>Publish \u03bb: publish({sender: alice, amount: 75, ...}, register = -25, previous = 50)?\n    Publish \u03bb--\x3e>Derivation: return {sender: alice, amount: 75, balance: -25, overdrawn: true}\n",mdxType:"Mermaid"}),(0,r.kt)("h3",{id:"creating-typescript-modules"},"Creating TypeScript modules"),(0,r.kt)("p",null,"To create a new TypeScript module for the lambdas of your derivation,\nyou can use ",(0,r.kt)("inlineCode",{parentName:"p"},"flowctl typescript generate")," to generate it.\nIn the derivation specification, choose the name for the new module and\nrun ",(0,r.kt)("inlineCode",{parentName:"p"},"flowctl typescript generate"),".\nFlow creates a module with the name you specified, stubs of the required interfaces,\nand TypeScript types that match your schemas.\nUpdate the module with your lambda function bodies,\nand proceed to test and deploy your catalog."),(0,r.kt)("p",null,"Using the example below, ",(0,r.kt)("inlineCode",{parentName:"p"},"flowctl typescript generate --source=acmeBank.flow.yaml")," will generate the stubbed-out acmeBank.ts."),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"acmeBank.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"collections:\n  acmeBank/balances:\n    schema: balances.schema.yaml\n    key: [/account]\n\n    derivation:\n      typescript:\n        module: acmeBank.ts\n      transform:\n        fromTransfers:\n          source: { name: acmeBank/transfers }\n          publish: { lambda: typescript }\n"))),(0,r.kt)(i.Z,{value:"acmeBank.ts (generated stub)",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { IDerivation, Document, Register, FromTransfersSource } from 'flow/acmeBank/balances';\n\n// Implementation for derivation examples/acmeBank.flow.yaml#/collections/acmeBank~1balances/derivation.\nexport class Derivation implements IDerivation {\n     fromTransfersPublish(\n        _source: FromTransfersSource,\n        _register: Register,\n        _previous: Register,\n    ): Document[] {\n        throw new Error(\"Not implemented\");\n    }\n}\n")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/concepts/flowctl#typescript-generation"},"Learn more about TypeScript generation")),(0,r.kt)("h3",{id:"npm-dependencies"},"NPM dependencies"),(0,r.kt)("p",null,"Your TypeScript modules may depend on other\n",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/"},"NPM packages"),",\nwhich can be be imported through the ",(0,r.kt)("inlineCode",{parentName:"p"},"npmDependencies"),"\nstanza of the ",(0,r.kt)("a",{parentName:"p",href:"#specification"},"derivation spec"),".\nFor example, ",(0,r.kt)("a",{parentName:"p",href:"https://momentjs.com/"},"moment")," is a common library\nfor working with times:"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"derivation.flow.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'derivation:\n  typescript:\n    module: first-send.ts\n    npmDependencies:\n      moment: "^2.24"\n  transform: { ... }\n'))),(0,r.kt)(i.Z,{value:"first-send.ts",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import * as moment from 'moment';\n\n// ... use `moment` as per usual.\n")))),(0,r.kt)("p",null,"Use any version string understood by ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),",\nwhich can include local packages, GitHub repository commits, and more.\nSee ",(0,r.kt)("a",{parentName:"p",href:"https://docs.npmjs.com/cli/v8/configuring-npm/package-json#dependencies"},"package.json documentation"),"."),(0,r.kt)("p",null,"During the catalog build process, Flow gathers NPM dependencies\nacross all Flow specification files and patches them into the catalog's\nmanaged ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),".\nFlow organizes its generated TypeScript project structure\nfor a seamless editing experience out of the box with VS Code\nand other common editors."),(0,r.kt)("h3",{id:"remote-lambdas"},"Remote lambdas"),(0,r.kt)("p",null,"A remote Lambda is one that you implement and host yourself as a web-accessible endpoint,\ntypically via a service like ",(0,r.kt)("a",{parentName:"p",href:"https://aws.amazon.com/lambda/"},"AWS Lambda")," or ",(0,r.kt)("a",{parentName:"p",href:"https://cloud.google.com/run"},"Google Cloud Run"),".\nFlow will invoke your remote Lambda as needed,\nPOST-ing JSON documents to process and expecting JSON documents in the response."),(0,r.kt)("h2",{id:"processing-order"},"Processing order"),(0,r.kt)("p",null,"Derivations may have multiple transformations that simultaneously read from\ndifferent source collections, or even multiple transformations that read\nfrom the same source collection."),(0,r.kt)("p",null,"Roughly speaking, the derivation will globally process transformations and\ntheir source documents in the time-based order in which the source documents\nwere originally written to their source collections.\nThis means that a derivation started a month ago\nand a new copy of the derivation started today,\nwill process documents in the same order and arrive at the same result.\nDerivations are ",(0,r.kt)("strong",{parentName:"p"},"repeatable"),"."),(0,r.kt)("p",null,"More precisely, processing order is stable for each individual shuffle key,\nthough different shuffle keys may process in different orders if more than\none task shard is used."),(0,r.kt)("p",null,"Processing order can be attenuated through a ",(0,r.kt)("strong",{parentName:"p"},"read delay"),"\nor differing transformation ",(0,r.kt)("strong",{parentName:"p"},"priority"),"."),(0,r.kt)("h2",{id:"read-delay"},"Read delay"),(0,r.kt)("p",null,"A transformation can define a read delay, which will hold back the processing\nof its source documents until the time delay condition is met.\nFor example, a read delay of 15 minutes would mean that a source document\ncannot be processed until it was published at least 15 minutes ago.\nIf the derivation is working through a historical backlog of source documents,\nthan a delayed transformation will respect its ordering delay relative\nto the publishing times of other historical documents also being read."),(0,r.kt)("p",null,"Event-driven workflows are a great fit for reacting to events as they occur,\nbut aren\u2019t terribly good at taking action when something ",(0,r.kt)("em",{parentName:"p"},"hasn\u2019t")," happened:"),(0,r.kt)("blockquote",null,(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"A user adds a product to their cart, but then doesn\u2019t complete a purchase."),(0,r.kt)("li",{parentName:"ul"},"A temperature sensor stops producing its expected, periodic measurements."))),(0,r.kt)("p",null,"A common pattern for tackling these workflows in Flow is to\nread a source collection without a delay and update a register.\nThen, read a collection with a read delay\nand determine whether the desired action has happened or not.\nFor example, source from a collection of sensor readings\nand index the last timestamp of each sensor in a register.\nThen, source the same collection again with a read delay:\nif the register timestamp isn't more recent\nthan the delayed source reading,\nthe sensor failed to produce a measurement."),(0,r.kt)("p",null,"Flow read delays are very efficient and scale better\nthan managing very large numbers of fine-grain timers."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/blob/master/examples/citi-bike/idle-bikes.flow.yaml"},"Learn more from the Citi Bike idle bikes example")),(0,r.kt)("h2",{id:"read-priority"},"Read priority"),(0,r.kt)("p",null,"Sometimes it's necessary for ",(0,r.kt)("em",{parentName:"p"},"all")," documents of a source collection\nto be processed by a transformation before ",(0,r.kt)("em",{parentName:"p"},"any")," documents of some\nother source collection are processed, regardless of their\nrelative publishing time.\nFor example, a collection may have corrections that should be\napplied before the historical data of another collection\nis re-processed."),(0,r.kt)("p",null,"Transformation priorities allow you to express the relative\nprocessing priority of a derivation's various transformations.\nWhen priorities are not equal, ",(0,r.kt)("em",{parentName:"p"},"all")," available source documents\nof a higher-priority transformation\nare processed before ",(0,r.kt)("em",{parentName:"p"},"any")," source documents\nof a lower-priority transformation."),(0,r.kt)("h2",{id:"where-to-accumulate"},"Where to accumulate?"),(0,r.kt)("p",null,"When you build a derived collection, you must choose where ",(0,r.kt)("strong",{parentName:"p"},"accumulation")," will happen:\nwhether Flow will reduce into documents held within\nyour materialization endpoint, or within the derivation's registers.\nThese two approaches can produce equivalent results,\nbut they do so in very different ways."),(0,r.kt)("h3",{id:"accumulate-in-your-database"},"Accumulate in your database"),(0,r.kt)("p",null,"To accumulate in your materialization endpoint, such as a database,\nyou define a derivation with a reducible schema\nand use only ",(0,r.kt)("inlineCode",{parentName:"p"},"publish")," lambdas and no registers.\nThe Flow runtime uses your reduction annotations\nto combine published documents, which are written to the collection.\nIt then fully reduces collection documents into the values\nstored in the database.\nThis keeps the materialized table up to date."),(0,r.kt)("p",null,"A key insight is that the database is\nthe ",(0,r.kt)("em",{parentName:"p"},"only")," stateful system in this scenario,\nand Flow uses reductions in two steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"To combine many published documents into intermediate ",(0,r.kt)("strong",{parentName:"li"},"delta documents"),",\nwhich are the documents written to collection storage."),(0,r.kt)("li",{parentName:"ol"},"To reduce delta states into the final database-stored document.")),(0,r.kt)("p",null,"For example, consider a collection that\u2019s summing a value:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Time"),(0,r.kt)("th",{parentName:"tr",align:null},"DB"),(0,r.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,r.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T0"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"0")),(0,r.kt)("td",{parentName:"tr",align:null},"publish(2, 1, 2)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5")),(0,r.kt)("td",{parentName:"tr",align:null},"publish(-2, 1)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4")),(0,r.kt)("td",{parentName:"tr",align:null},"publish(3, -2, 1)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6")),(0,r.kt)("td",{parentName:"tr",align:null},"publish()"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"This works especially well when materializing into a transactional database.\nFlow couples its processing transactions with corresponding database transactions,\nensuring end-to-end \u201cexactly once\u201d semantics."),(0,r.kt)("p",null,'When materializing into a non-transactional store,\nFlow is only able to provide weaker \u201cat least once\u201d semantics;\nit\u2019s possible that a document may be combined into a database value more than once.\nWhether that\u2019s a concern depends a bit on the task at hand.\nSome reductions can be applied repeatedly without changing the result (they\'re "idempotent"),\nwhile in other use cases approximations are acceptable.\nFor the summing example above,\n"at-least-once" semantics could give an incorrect result.'),(0,r.kt)("h3",{id:"accumulate-in-registers"},"Accumulate in registers"),(0,r.kt)("p",null,"To accumulate in registers,\nyou use a derivation that defines a reducible register schema\nthat's updated through ",(0,r.kt)("strong",{parentName:"p"},"update")," lambdas.\nThe Flow runtime allocates, manages, and scales durable storage for registers; you don\u2019t have to.\nThen you use ",(0,r.kt)("strong",{parentName:"p"},"publish")," lambdas to publish a snapshot of your register value into your collection."),(0,r.kt)("p",null,"Returning to our summing example:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Time"),(0,r.kt)("th",{parentName:"tr",align:null},"Register"),(0,r.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,r.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T0"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"0")),(0,r.kt)("td",{parentName:"tr",align:null},"update(2, 1, 2), publish(register)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"5")),(0,r.kt)("td",{parentName:"tr",align:null},"update(-2, 1), publish(register)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"4")),(0,r.kt)("td",{parentName:"tr",align:null},"update(3, -2, 1), publish(register)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"6")),(0,r.kt)("td",{parentName:"tr",align:null},"update()"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"Register derivations are a great solution for materializations\ninto non-transactional stores\nbecause the documents they produce\ncan be applied multiple times without breaking correctness."),(0,r.kt)("p",null,"They\u2019re also well-suited for materializations into endpoints that aren't stateful,\nsuch as pub/sub systems or Webhooks,\nbecause they can produce fully reduced values as stand-alone updates."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/tree/master/examples/derive-patterns"},"Learn more in the derivation pattern examples of Flow's repository")))}h.isMDXComponent=!0},1748:(e,n,t)=>{var a={"./locale":9234,"./locale.js":9234};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=s,e.exports=r,r.id=1748},7918:(e,n,t)=>{"use strict";t.d(n,{Z:()=>a});const a=t.p+"assets/images/derivations-new-c666a7a8e6d39080ba1d56eb5197dcfe.svg"}}]);