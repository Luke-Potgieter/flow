"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[2536],{8215:function(e,n,t){var a=t(7294);n.Z=function(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},6396:function(e,n,t){t.d(n,{Z:function(){return m}});var a=t(7462),r=t(7294),i=t(2389),s=t(9443);var o=function(){var e=(0,r.useContext)(s.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=t(3616),c=t(6010),d="tabItem_vU9c";function u(e){var n,t,i,s=e.lazy,u=e.block,m=e.defaultValue,p=e.values,h=e.groupId,f=e.className,k=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=p?p:k.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),b=(0,l.lx)(g,(function(e,n){return e.value===n.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===m?m:null!=(n=null!=m?m:null==(t=k.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(i=k[0])?void 0:i.props.value;if(null!==y&&!g.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=o(),w=v.tabGroupChoices,N=v.setTabGroupChoices,T=(0,r.useState)(y),x=T[0],B=T[1],D=[],A=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var C=w[h];null!=C&&C!==x&&g.some((function(e){return e.value===C}))&&B(C)}var R=function(e){var n=e.currentTarget,t=D.indexOf(n),a=g[t].value;a!==x&&(A(n),B(a),null!=h&&N(h,a))},I=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a=D.indexOf(e.currentTarget)+1;t=D[a]||D[0];break;case"ArrowLeft":var r=D.indexOf(e.currentTarget)-1;t=D[r]||D[D.length-1]}null==(n=t)||n.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":u},f)},g.map((function(e){var n=e.value,t=e.label,i=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===n?0:-1,"aria-selected":x===n,key:n,ref:function(e){return D.push(e)},onKeyDown:I,onFocus:R,onClick:R},i,{className:(0,c.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":x===n})}),null!=t?t:n)}))),s?(0,r.cloneElement)(k.filter((function(e){return e.props.value===x}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},k.map((function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==x})}))))}function m(e){var n=(0,i.Z)();return r.createElement(u,(0,a.Z)({key:String(n)},e))}},1504:function(e,n,t){var a=t(7294),r=t(7273);r.Z.initialize({startOnLoad:!0});n.Z=function(e){var n=e.chart;return(0,a.useEffect)((function(){r.Z.contentLoaded()}),[]),a.createElement("div",{className:"mermaid"},n)}},9596:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return d},contentTitle:function(){return u},metadata:function(){return m},toc:function(){return p},default:function(){return f}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),s=t(6396),o=t(8215),l=t(1504),c=["components"],d={},u="Derivations",m={unversionedId:"concepts/derivations",id:"concepts/derivations",title:"Derivations",description:"A derivation is a collection",source:"@site/docs/concepts/derivations.md",sourceDirName:"concepts",slug:"/concepts/derivations",permalink:"/concepts/derivations",editUrl:"https://github.com/estuary/flow/edit/master/site/docs/concepts/derivations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Connectors",permalink:"/concepts/connectors"},next:{title:"flowctl",permalink:"/concepts/flowctl"}},p=[{value:"Specification",id:"specification",children:[],level:2},{value:"Background",id:"background",children:[],level:2},{value:"Transformations",id:"transformations",children:[],level:2},{value:"Sources",id:"sources",children:[],level:2},{value:"Shuffles",id:"shuffles",children:[],level:2},{value:"Publish Lambdas",id:"publish-lambdas",children:[],level:2},{value:"Registers",id:"registers",children:[],level:2},{value:"Update Lambdas",id:"update-lambdas",children:[],level:2},{value:"Processing Order",id:"processing-order",children:[],level:2},{value:"Read Delay",id:"read-delay",children:[],level:2},{value:"Read Priority",id:"read-priority",children:[],level:2},{value:"Where to accumulate?",id:"where-to-accumulate",children:[{value:"Accumulate in your Database",id:"accumulate-in-your-database",children:[],level:3},{value:"Accumulate in Registers",id:"accumulate-in-registers",children:[],level:3}],level:2}],h={toc:p};function f(e){var n=e.components,d=(0,r.Z)(e,c);return(0,i.kt)("wrapper",(0,a.Z)({},h,d,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"derivations"},"Derivations"),(0,i.kt)("p",null,"A derivation is a ",(0,i.kt)("a",{parentName:"p",href:"/concepts/collections"},"collection"),"\nwhich continuously derives its documents\nfrom transformations that are applied to one or more other source collections.\nIt defines both the collection of derived documents,\nand also a ",(0,i.kt)("a",{parentName:"p",href:"../#tasks"},"catalog task"),"\nwhich processes documents of source collections as they become available,\ntransforming them into updates of the derived collection."),(0,i.kt)("p",null,"In addition to their collection,\nderivations are defined by their ",(0,i.kt)("strong",{parentName:"p"},"transformations")," and ",(0,i.kt)("strong",{parentName:"p"},"registers"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{src:t(9353).Z})),(0,i.kt)("h2",{id:"specification"},"Specification"),(0,i.kt)("p",null,"Derivations are specified as a regular collection which has an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"derivation")," stanza:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'collections:\n  # The unique name of the derivation.\n  acmeCo/my/derivation:\n    schema: my-schema.yaml\n    key: [/key]\n\n    # Presence of a `derivation` stanza makes this collection a derivation.\n    # Type: object\n    derivation:\n\n      # Register definition of the derivation.\n      # If not provided, registers have an unconstrained schema\n      # and initialize to the `null` value.\n      # Optional, type: object\n      register:\n\n        # JSON Schema of register documents. As with collection schemas,\n        # this is either an inline definition or a relative URL reference.\n        # Required, type: string (relative URL form) or object (inline form)\n        schema:\n          type: integer\n\n        # Initial value taken by a register which has never been updated before.\n        # Optional, default: null\n        initial: 0\n\n      # Transformations of the derivation,\n      # specified as a map of named transformations.\n      transform:\n\n        # Unique name of the transformation, containing only Unicode\n        # Letters and Numbers (no spaces or punctuation).\n        myTransformName:\n\n          # Source collection read by this transformation.\n          # Required, type: object\n          source:\n            # Name of the collection to be read.\n            # Required.\n            name: acmeCo/my/source/collection\n            # JSON Schema to validate against the source collection.\n            # If not set, the schema of the source collection is used.\n            # Optional, type: string (relative URL form) or object (inline form)\n            schema: {}\n            # Partition selector of the source collection.\n            # Optional. Default is to read all partitions.\n            partitions: {}\n\n          # Delay applied to sourced documents before being processed\n          # by this transformation.\n          # Default: No delay, pattern: ^\\\\d+(s|m|h)$\n          readDelay: "48h"\n\n          # Shuffle determines the key by which source documents are\n          # shuffled (mapped) to a register.\n          # Optional, type: object.\n          # If not provided, documents are shuffled on the source collection key.\n          shuffle:\n            # Key is a composite key which is extracted from documents\n            # of the source.\n            key: [/shuffle/key/one, /shuffle/key/two]\n\n          # Update lambda of the transformation.\n          # Optional, type: object\n          update: {lambda: typescript}\n\n          # Publish lambda of the transformation.\n          # Optional, type: object\n          publish: {lambda: typescript}\n\n          # Priority applied to processing documents of this transformation\n          # relative to other transformations of the derivation.\n          # Default: 0, integer >= 0\n          priority: 0\n\n')),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"For the sake of explanations in the following sections,\nsuppose you have an application where users send one another\nsome amount of currency, like in-game tokens or dollars or digital kittens:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"transfers.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.flow.yaml",file:"./bank/transfers.flow.yaml"},"collections:\n  # Collection of \ud83d\udcb2 transfers between accounts:\n  #   {id: 123, sender: alice, recipient: bob, amount: 32.50}\n  acmeBank/transfers:\n    schema: transfers.schema.yaml\n    key: [/id]\n"))),(0,i.kt)(o.Z,{value:"transfers.schema.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/transfers.schema.yaml",file:"./bank/transfers.schema.yaml"},"type: object\nproperties:\n  id: { type: integer }\n  sender: { type: string }\n  recipient: { type: string }\n  amount: { type: number }\nrequired: [id, sender, recipient, amount]\n")))),(0,i.kt)("p",null,"There are many views over this data that you might require,\nsuch as summaries of sender or receiver activity,\nor current account balances\nwithin your application."),(0,i.kt)("p",null,"The following sections will refer to this example when discussing concepts."),(0,i.kt)("h2",{id:"transformations"},"Transformations"),(0,i.kt)("p",null,"A transformation binds a ",(0,i.kt)("a",{parentName:"p",href:"#sources"},"source")," collection to a derivation.\nAs documents of the source collection arrive,\nthe transformation processes the document\nto ",(0,i.kt)("a",{parentName:"p",href:"#publish-lambdas"},"publish")," new documents,\nor ",(0,i.kt)("a",{parentName:"p",href:"#update-lambdas"},"update")," a\n",(0,i.kt)("a",{parentName:"p",href:"#registers"},"register"),",\nor both."),(0,i.kt)("p",null,"Read source documents are ",(0,i.kt)("a",{parentName:"p",href:"#shuffles"},"shuffled")," on a ",(0,i.kt)("strong",{parentName:"p"},"shuffle key")," to\nco-locate the processing of documents that have equal shuffle keys.\nThe transformation then processes documents by invoking ",(0,i.kt)("strong",{parentName:"p"},"lambdas"),":\nuser-defined functions which accept documents as arguments\nand return documents in response."),(0,i.kt)("p",null,"A derivation may have many transformations,\nand each transformation has a long-lived and stable name.\nEach transformation independently reads documents from its\nsource collection and tracks its own read progress.\nMore than one transformation can read from the same source collection,\nand transformations may also source from their own derivation\n\u2014 enabling cyclic data-flows and graph algorithms."),(0,i.kt)("p",null,"Transformations may be added or removed from a derivation at any time.\nThis makes it possible to, for example, add a new collection into an\nexisting multi-way join, or to gracefully migrate to a new source\ncollection without incurring downtime.\nHowever renaming a running transformation is not possible:\nif attempted, the old transformation is dropped and\na new transformation under the new name is created,\nwhich begins reading its source collection all over again."),(0,i.kt)(l.Z,{chart:"\n\tgraph LR;\n    d[Derivation];\n    t[Transformation];\n    r[Registers];\n    p[Publish \u03bb];\n    u[Update \u03bb];\n    c[Sourced Collection];\n    d-- has many --\x3et;\n    t-- reads from --\x3ec;\n    t-- invokes --\x3eu;\n    t-- invokes --\x3ep;\n    u-- updates --\x3er;\n    r-- reads --\x3ep;\n    d-- indexes --\x3er;\n",mdxType:"Mermaid"}),(0,i.kt)("h2",{id:"sources"},"Sources"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"source")," of a transformation is a collection.\nAs documents are published into the source collection,\nthey are continuously read and processed by the transformation."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"/concepts/projections#partition-selectors"},"partition selector")," may be provided\nto process only a subset of the logical partitions of the source collection.\nSelectors are efficient: only partitions which match the selector are read,\nand Flow can cheaply skip over partitions that don't."),(0,i.kt)("p",null,"Derivations re-validate their source documents against\nthe source collection's schema as they are read.\nThis is because collection schemas may evolve over time,\nand could have inadvertently become incompatible with\nhistorical documents of the source collection.\nUpon a schema error, the derivation will pause and\ngive you an opportunity to correct the problem."),(0,i.kt)("p",null,"You may also provide an alternative ",(0,i.kt)("strong",{parentName:"p"},"source schema"),".\nSource schemas aide in processing third-party sources\nof data that you don't control,\nthat can have unexpected schema changes without notice.\nYou may want to capture this data\nwith a minimal and very permissive schema.\nThen, a derivation can apply a significantly stricter source schema\nwhich verifies your current expectations of what the data ",(0,i.kt)("em",{parentName:"p"},"should")," be.\nIf those expectations turn out to be wrong,\nlittle harm is done:\nyour derivation is paused but the capture continues to run.\nYou next update your transformations\nto account for the upstream changes and then continue without any data loss."),(0,i.kt)("h2",{id:"shuffles"},"Shuffles"),(0,i.kt)("p",null,"As each source document is read, it's shuffled \u2014 or equivalently, mapped \u2014\non an extracted key."),(0,i.kt)("p",null,"If you're familiar with data shuffles in tools like MapReduce, Apache Spark,\nor Flink, the concept is very similar.\nFlow catalog tasks scale to run across many machines at the same time,\nwhere each machine processes a subset of source documents.\nShuffles let Flow know how to group documents so that they're co-located,\nwhich can increase processing efficiency and reduce data volumes.\nThey are also used to map source documents to ",(0,i.kt)("a",{parentName:"p",href:"#registers"},"registers"),"."),(0,i.kt)(l.Z,{chart:"\n\tgraph LR;\n    subgraph s1 [Source Partitions]\n      p1>acmeBank/transfers/part-1];\n      p2>acmeBank/transfers/part-2];\n    end\n    subgraph s2 [Derivation Task Shards]\n      t1([task/shard-1]);\n      t2([task/shard-2]);\n    end\n    p1-- sender: alice --\x3et1;\n    p1-- sender: bob --\x3et2;\n    p2-- sender: alice --\x3et1;\n    p2-- sender: bob --\x3et2;\n",mdxType:"Mermaid"}),(0,i.kt)("p",null,"If you don't provide a shuffle key\nthen Flow will shuffle on the source collection key,\nwhich is typically what you want."),(0,i.kt)("p",null,"If a derivation has more than one transformation,\nthe shuffle keys of all transformations must align with one another\non the extracted key types (string versus integer)\nand also the number of components in a composite key.\nFor example, one transformation couldn't shuffle transfers on ",(0,i.kt)("inlineCode",{parentName:"p"},"[/id]"),"\nwhile another shuffles on ",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender]"),", because ",(0,i.kt)("inlineCode",{parentName:"p"},"sender")," is a string and\n",(0,i.kt)("inlineCode",{parentName:"p"},"id")," an integer.\nSimilarly mixing a shuffle of ",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender]")," alongside ",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]"),"\nis prohibited because the keys have different numbers of components.\nHowever, one transformation ",(0,i.kt)("em",{parentName:"p"},"can")," shuffle on ",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender]"),"\nwhile another shuffles on ",(0,i.kt)("inlineCode",{parentName:"p"},"[/recipient]"),",\nas is done in the examples below."),(0,i.kt)("h2",{id:"publish-lambdas"},"Publish Lambdas"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"publish")," lambda publishes documents into the derived collection."),(0,i.kt)("p",null,"To illustrate first with an example,\nsuppose you must know the last transfer\nfrom each sender which was over $100:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"last-large-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send.flow.yaml",file:"./bank/last-large-send.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  acmeBank/last-large-send:\n    schema: transfers.schema.yaml\n    key: [/sender]\n\n    derivation:\n      transform:\n        fromTransfers:\n          source:\n            name: acmeBank/transfers\n          publish:\n            lambda: typescript\n"))),(0,i.kt)(o.Z,{value:"last-large-send.flow.ts",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/last-large-send.flow.ts",file:"./bank/last-large-send.flow.ts"},"import { collections, interfaces, registers } from 'flow/modules';\n\n// Implementation for derivation examples/bank/last-large-send.flow.yaml#/collections/acmeBank~1last-large-send/derivation.\nexport class AcmeBankLastLargeSend implements interfaces.AcmeBankLastLargeSend {\n    fromTransfersPublish(\n        source: collections.AcmeBankTransfers,\n        _register: registers.AcmeBankLastLargeSend,\n        _previous: registers.AcmeBankLastLargeSend,\n    ): collections.AcmeBankLastLargeSend[] {\n        if (source.amount > 100) {\n            return [source]; // This is a large send.\n        }\n        return []; // Filter this `source` document.\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"last-large-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/last-large-send-test.flow.yaml",file:"./bank/last-large-send-test.flow.yaml"},"import:\n  - last-large-send.flow.yaml\n\ntests:\n  acmeBank/tests/last-large-send:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial set of transfers amongst users\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 2, sender: bob, recipient: alice, amount: 10.22 }\n          - { id: 3, sender: carol, recipient: bob, amount: 327.00 }\n    - ingest:\n        collection: acmeBank/transfers\n        description: Alice and Carol later send additional transfers.\n        documents:\n          - { id: 4, sender: alice, recipient: carol, amount: 32.50 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n    - verify:\n        collection: acmeBank/last-large-send\n        description: |\n          Expect the most-recent of Carol's large transfers is tracked,\n          along with Alice's only large transfer.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 125.10 }\n          - { id: 5, sender: carol, recipient: alice, amount: 226.73 }\n")))),(0,i.kt)("p",null,"This transformation defines a TypeScript ",(0,i.kt)("strong",{parentName:"p"},"publish")," lambda\nwhich is implemented in an accompanying TypeScript module.\nThe lambda is invoked as each source transfer document arrives,\nand is given the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," document\nas well as a ",(0,i.kt)("inlineCode",{parentName:"p"},"_register")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"_previous")," register which are not used here.\nMore on ",(0,i.kt)("a",{parentName:"p",href:"#registers"},"registers")," in a bit.\nThe lambda outputs zero or more documents,\neach of which must conform to the derivation's schema."),(0,i.kt)("p",null,"As this derivation's collection is keyed on ",(0,i.kt)("inlineCode",{parentName:"p"},"/sender"),",\nthe last published document (the last large transfer) of each sender is retained.\nIf it were instead keyed on ",(0,i.kt)("inlineCode",{parentName:"p"},"/id"),",\nthen ",(0,i.kt)("em",{parentName:"p"},"all")," transfers with large amounts would be retained.\nIn SQL terms, the collection key acts as a GROUP BY."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Flow will initialize a TypeScript module for your lambdas if one doesn't exist,\nwith stubs of the required interfaces\nand having TypeScript types that match your schemas.\nYou just write the function body."),(0,i.kt)("p",{parentName:"div"},(0,i.kt)("a",{parentName:"p",href:"/concepts/flowctl#typescript-generation"},"Learn more about TypeScript generation")))),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Derivation collection schemas may have\n",(0,i.kt)("a",{parentName:"p",href:"/concepts/schemas#reductions"},"reduction")," annotations,\nand publish lambdas can be combined with reductions in interesting ways."),(0,i.kt)("p",null,"You may be familiar with ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," functions\nbuilt into languages like\n",(0,i.kt)("a",{parentName:"p",href:"https://book.pythontips.com/en/latest/map_filter.html"},"Python"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://www.freecodecamp.org/news/javascript-map-reduce-and-filter-explained-with-examples/"},"JavaScript"),',\nand many others,\nor have used tools like MapReduce or Spark.\nIn functional terms, lambdas you write within Flow are "mappers",\nand reductions are always done\nby the Flow runtime using your schema annotations.'),(0,i.kt)("p",null,"Suppose you need to know the running\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Double-entry_bookkeeping"},"account balances"),"\nof your users given all of their transfers thus far.\nTackle this by ",(0,i.kt)("em",{parentName:"p"},"reducing")," the final account balance\nfor each user from all of the credit and debit amounts of their transfers:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"balances.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/balances.flow.yaml",file:"./bank/balances.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  acmeBank/balances:\n    schema:\n      type: object\n      required: [user]\n      reduce: { strategy: merge }\n      properties:\n        user: { type: string }\n        balance:\n          type: number\n          reduce: { strategy: sum }\n    key: [/user]\n\n    derivation:\n      transform:\n        fromTransfers:\n          source:\n            name: acmeBank/transfers\n          publish:\n            lambda: typescript\n"))),(0,i.kt)(o.Z,{value:"balances.flow.ts",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/balances.flow.ts",file:"./bank/balances.flow.ts"},"import { collections, interfaces, registers } from 'flow/modules';\n\n// Implementation for derivation site/docs/concepts/derivations/bank/balances.flow.yaml#/collections/acmeBank~1balances/derivation.\nexport class AcmeBankBalances implements interfaces.AcmeBankBalances {\n    fromTransfersPublish(\n        source: collections.AcmeBankTransfers,\n        _register: registers.AcmeBankBalances,\n        _previous: registers.AcmeBankBalances,\n    ): collections.AcmeBankBalances[] {\n        return [\n            // Debit the sender.\n            { user: source.sender, balance: -source.amount },\n            // Credit the recipient.\n            { user: source.recipient, balance: source.amount },\n        ];\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"balances-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/balances-test.flow.yaml",file:"./bank/balances-test.flow.yaml"},"import:\n  - balances.flow.yaml\n\ntests:\n  acmeBank/tests/balances:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial deposits into user accounts.\n        documents:\n          - { id: 1, sender: CREDIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: CREDIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: CREDIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: acmeBank/transfers\n        description: Transfers between users, and a withdraw.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 20 }\n          - { id: 5, sender: bob, recipient: carol, amount: 40 }\n          - { id: 6, sender: carol, recipient: alice, amount: 90 }\n          - { id: 7, sender: bob, recipient: CREDIT, amount: 40 }\n\n    - verify:\n        collection: acmeBank/balances\n        description: Verify expected balances.\n        documents:\n          - { user: CREDIT, balance: -260 }\n          - { user: alice, balance: 170 }\n          - { user: bob, balance: 40 }\n          - { user: carol, balance: 50 }\n")))),(0,i.kt)("h2",{id:"registers"},"Registers"),(0,i.kt)("p",null,"Registers are the internal ",(0,i.kt)("em",{parentName:"p"},"memory")," of a derivation.\nThey are a building block which enable derivations to tackle advanced stateful\nstreaming computations like multi-way joins, windowing, and transaction processing.\nAs we've already seen, not all derivations require registers\nbut they are essential for a variety of important use cases."),(0,i.kt)("p",null,"Each register is a document with a user-defined\n",(0,i.kt)("a",{parentName:"p",href:"/concepts/schemas"},"schema"),".\nRegisters are keyed, and every derivation maintains an index of keys\nand their corresponding register documents.\nEvery source document is mapped to a specific register document\nthrough its extracted ",(0,i.kt)("a",{parentName:"p",href:"#shuffles"},"shuffle key"),"."),(0,i.kt)("p",null,"For example, when shuffling ",(0,i.kt)("inlineCode",{parentName:"p"},"acmeBank/transfers")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender]"),'\nthen each account ("alice", "bob", or "carol")\nwould be allocated its own register.\nIf you instead shuffle on ',(0,i.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]")," then each\n",(0,i.kt)("em",{parentName:"p"},"pair"),' of accounts ("alice -> bob", "alice -> carol", "bob -> carol")\nwould be allocated a register.'),(0,i.kt)("p",null,"Registers are best suited for relatively small,\nfast-changing documents that are shared within and across\nthe transformations of a derivation.\nThe number of registers indexed within a derivation may be very large,\nand if a register has never before been used\nit starts with a user-defined initial value.\nFrom there, registers may be modified through an ",(0,i.kt)("strong",{parentName:"p"},"update lambda"),"."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Under the hood, registers are backed by replicated,\nembedded RocksDB instances which co-locate\nwith the lambda execution contexts that Flow manages.\nAs contexts are assigned and re-assigned,\ntheir register databases travel with them."),(0,i.kt)("p",{parentName:"div"},"If any single RocksDB instance becomes too large,\nFlow is able to perform an online ",(0,i.kt)("strong",{parentName:"p"},"split"),",\nwhich subdivides its contents into two new databases\n\u2014 and paired execution contexts \u2014 which are re-assigned to other machines."))),(0,i.kt)("h2",{id:"update-lambdas"},"Update Lambdas"),(0,i.kt)("p",null,"An ",(0,i.kt)("strong",{parentName:"p"},"update")," lambda transforms a source document\ninto an update of the source document's register."),(0,i.kt)("p",null,"To again illustrate through an example,\nsuppose your compliance department wants you to flag\nthe first transfer a sender sends to a new recipient.\nYou achieve this by shuffling on pairs of\n",(0,i.kt)("inlineCode",{parentName:"p"},"[/sender, /recipient]")," and using a register\nto track whether this account pair has been seen before:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"first-send.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send.flow.yaml",file:"./bank/first-send.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  acmeBank/first-send:\n    schema: transfers.schema.yaml\n    key: [/id]\n\n    derivation:\n      # We'll store a `true/false` boolean in our register documents,\n      # which is initially `false` and becomes `true` after the first transfer.\n      register:\n        schema: { type: boolean }\n        initial: false\n\n      transform:\n        fromTransfers:\n          source:\n            name: acmeBank/transfers\n          # Shuffle so that each account pair\n          # is allocated its own register.\n          shuffle:\n            key: [/sender, /recipient]\n          update:\n            lambda: typescript\n          publish:\n            lambda: typescript\n"))),(0,i.kt)(o.Z,{value:"first-send.flow.ts",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/first-send.flow.ts",file:"./bank/first-send.flow.ts"},"import { collections, interfaces, registers } from 'flow/modules';\n\n// Implementation for derivation site/docs/concepts/derivations/bank/first-send.flow.yaml#/collections/acmeBank~1first-send/derivation.\nexport class AcmeBankFirstSend implements interfaces.AcmeBankFirstSend {\n    fromTransfersUpdate(_source: collections.AcmeBankTransfers): registers.AcmeBankFirstSend[] {\n        return [true]; // Toggle the register from `false` => `true`.\n    }\n    fromTransfersPublish(\n        source: collections.AcmeBankTransfers,\n        _register: registers.AcmeBankFirstSend,\n        previous: registers.AcmeBankFirstSend,\n    ): collections.AcmeBankFirstSend[] {\n        // If the register was previously false, than this is the first\n        // transfer for this account pair.\n        if (!previous) {\n            return [source];\n        }\n        return []; // Not the first transfer.\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"first-send-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/first-send-test.flow.yaml",file:"./bank/first-send-test.flow.yaml"},"import:\n  - first-send.flow.yaml\n\ntests:\n  acmeBank/tests/first-send:\n    - ingest:\n        collection: acmeBank/transfers\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 2, sender: alice, recipient: bob, amount: 13.40 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n          - { id: 5, sender: carol, recipient: alice, amount: 2.36 }\n          - { id: 6, sender: alice, recipient: carol, amount: 7.13 }\n\n    - verify:\n        collection: acmeBank/first-send\n        description: |\n          Expect we filtered to the first interaction of each account pair.\n        documents:\n          - { id: 1, sender: alice, recipient: bob, amount: 10.25 }\n          - { id: 3, sender: carol, recipient: alice, amount: 12.50 }\n          - { id: 4, sender: alice, recipient: carol, amount: 16.96 }\n")))),(0,i.kt)("p",null,"This transformation uses both a publish and an ",(0,i.kt)("strong",{parentName:"p"},"update")," lambda,\nimplemented in an accompanying TypeScript module.\nThe update lambda is invoked first for each ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," document,\nand it returns zero or more documents\nwhich each must conform to the derivation's register schema\n(in this case, a simple boolean)."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"publish")," lambda is invoked next, and is given the ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"\ndocument as well as the ",(0,i.kt)("em",{parentName:"p"},"before")," (",(0,i.kt)("inlineCode",{parentName:"p"},"previous"),") and ",(0,i.kt)("em",{parentName:"p"},"after")," (",(0,i.kt)("inlineCode",{parentName:"p"},"_register"),")\nvalues of the updated register.\nIn this case we don't need the ",(0,i.kt)("em",{parentName:"p"},"after")," value:\nour update lambda implementation implies that it's always ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),".\nThe ",(0,i.kt)("em",{parentName:"p"},"before")," value, however,\ntells us whether this was the very first update of this register,\nand by implication was the first transfer for this pair of accounts."),(0,i.kt)(l.Z,{chart:'\n  sequenceDiagram\n    autonumber\n    Derivation->>Update \u03bb: update({sender: alice, recipient: bob})?\n    Update \u03bb--\x3e>Derivation: return "true"\n    Derivation->>Registers: lookup(key = [alice, bob])?\n    Registers--\x3e>Derivation: not found, initialize as "false"\n    Derivation--\x3e>Derivation: Register: "false" => "true"\n    Derivation-)Registers: store(key = [alice, bob], value = "true")\n    Derivation->>Publish \u03bb: publish({sender: alice, recipient: bob}, register = "true", previous = "false")?\n    Publish \u03bb--\x3e>Derivation: return {sender: alice, recipient: bob}\n',mdxType:"Mermaid"}),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"FAQ")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("blockquote",{parentName:"div"},(0,i.kt)("p",{parentName:"blockquote"},"Why not have one lambda that can return\na register update ",(0,i.kt)("em",{parentName:"p"},"and")," derived documents?")),(0,i.kt)("p",{parentName:"div"},(0,i.kt)("strong",{parentName:"p"},"Performance."),"\n",(0,i.kt)("em",{parentName:"p"},"Update")," and ",(0,i.kt)("em",{parentName:"p"},"publish")," are designed to be\nparallelized and pipelined over many source documents simultaneously,\nwhile still giving the appearance and correctness of lambdas which\nare invoked in strict serial order.\nNotice that (1) above doesn't depend on actually knowing the register\nvalue, which doesn't happen until (4).\nMany calls like (1) can also happen in parallel,\nso long as their applications to the register value (5)\nhappen in the correct order.\nIn comparison, a single-lambda design\nwould require Flow to await each invocation\nbefore it can begin the next."))),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Register schemas may also have\n",(0,i.kt)("a",{parentName:"p",href:"/concepts/schemas#reductions"},"reduction")," annotations,\nand documents returned by update lambdas\nare ",(0,i.kt)("em",{parentName:"p"},"reduced")," into the current register value."),(0,i.kt)("p",null,"The compliance department reached out again,\nand this time they need you to identify transfers where\nthe sender's account had insufficient funds."),(0,i.kt)("p",null,"You manage this by tracking\nthe running credits and debits of each account in a register.\nThen, you enrich each transfer with the account's current balance\nand whether the account was overdrawn:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"flagged-transfers.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/flagged-transfers.flow.yaml",file:"./bank/flagged-transfers.flow.yaml"},"import:\n  - transfers.flow.yaml\n\ncollections:\n  acmeBank/flagged-transfers:\n    schema:\n      # Extend transfer schema with `balance` and `overdrawn` fields.\n      $ref: transfers.schema.yaml\n      required: [balance, overdrawn]\n      properties:\n        balance: { type: number }\n        overdrawn: { type: boolean }\n    key: [/id]\n\n    projections:\n      # Logically partition on transfers which are flagged as overdrawn.\n      overdrawn:\n        location: /overdrawn\n        partition: true\n\n    derivation:\n      # Registers track the current balance of each account.\n      register:\n        schema:\n          type: number\n          reduce: { strategy: sum }\n        initial: 0\n\n      transform:\n        fromTransferSender:\n          source: { name: acmeBank/transfers }\n          shuffle: { key: [/sender] }\n          # Debit the sender's register balance.\n          update: { lambda: typescript }\n          # Publish transfer enriched with current sender balance.\n          publish: { lambda: typescript }\n\n        fromTransferRecipient:\n          source: { name: acmeBank/transfers }\n          shuffle: { key: [/recipient] }\n          # Credit the recipient's register balance.\n          update: { lambda: typescript }\n"))),(0,i.kt)(o.Z,{value:"flagged-transfers.flow.ts",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"file=./bank/flagged-transfers.flow.ts",file:"./bank/flagged-transfers.flow.ts"},"import { collections, interfaces, registers } from 'flow/modules';\n\n// Implementation for derivation site/docs/concepts/derivations/bank/flagged-transfers.flow.yaml#/collections/acmeBank~1flagged-transfers/derivation.\nexport class AcmeBankFlaggedTransfers implements interfaces.AcmeBankFlaggedTransfers {\n    fromTransferRecipientUpdate(source: collections.AcmeBankTransfers): registers.AcmeBankFlaggedTransfers[] {\n        return [source.amount]; // Credit recipient.\n    }\n    fromTransferSenderUpdate(source: collections.AcmeBankTransfers): registers.AcmeBankFlaggedTransfers[] {\n        return [-source.amount]; // Debit sender.\n    }\n    fromTransferSenderPublish(\n        source: collections.AcmeBankTransfers,\n        balance: registers.AcmeBankFlaggedTransfers,\n        _previous: registers.AcmeBankFlaggedTransfers,\n    ): collections.AcmeBankFlaggedTransfers[] {\n        if (balance > 0 || source.sender == 'CREDIT') {\n            return [{ ...source, balance: balance, overdrawn: false }];\n        } else {\n            return [{ ...source, balance: balance, overdrawn: true }];\n        }\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"flagged-transfers-test.flow.yaml",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"file=./bank/flagged-transfers-test.flow.yaml",file:"./bank/flagged-transfers-test.flow.yaml"},"import:\n  - flagged-transfers.flow.yaml\n\ntests:\n  acmeBank/tests/flagged-transfers:\n    - ingest:\n        collection: acmeBank/transfers\n        description: Initial deposits.\n        documents:\n          - { id: 1, sender: CREDIT, recipient: alice, amount: 100 }\n          - { id: 2, sender: CREDIT, recipient: bob, amount: 100 }\n          - { id: 3, sender: CREDIT, recipient: carol, amount: 100 }\n\n    - ingest:\n        collection: acmeBank/transfers\n        description: Transfers between users.\n        documents:\n          - { id: 4, sender: alice, recipient: bob, amount: 50 }\n          - { id: 5, sender: bob, recipient: carol, amount: 75 }\n\n    - ingest:\n        collection: acmeBank/transfers\n        description: |\n          Further transfers between users, with one being an overdraft.\n        documents:\n          - { id: 6, sender: alice, recipient: carol, amount: 75 }\n          - { id: 7, sender: carol, recipient: bob, amount: 175 }\n\n    - verify:\n        collection: acmeBank/flagged-transfers\n        description: |\n          Expect transfer #6 was flagged as being overdrawn.\n        partitions:\n          include:\n            overdrawn: [true]\n        documents:\n          - {\n              id: 6,\n              amount: 75,\n              balance: -25,\n              overdrawn: true,\n              recipient: carol,\n              sender: alice,\n            }\n")))),(0,i.kt)("p",null,"Source transfers are read twice,\nwith the first read shuffling on ",(0,i.kt)("inlineCode",{parentName:"p"},"/recipient"),"\nto track account credits,\nand the second shuffling on ",(0,i.kt)("inlineCode",{parentName:"p"},"/sender"),"\nto track account debits and to publish enriched transfer events.\nUpdate lambdas return the amount of credit or debit,\nand these amounts are summed\ninto a derivation register keyed on the account."),(0,i.kt)(l.Z,{chart:"\n  sequenceDiagram\n    autonumber\n    Derivation->>Registers: lookup(key = alice)?\n    Registers--\x3e>Derivation: not found, initialize as 0\n    Derivation->>Update \u03bb: update({recipient: alice, amount: 50, ...})?\n    Update \u03bb--\x3e>Derivation: return +50\n    Derivation->>Update \u03bb: update({sender: alice, amount: 75, ...})?\n    Update \u03bb--\x3e>Derivation: return -75\n    Derivation--\x3e>Derivation: Register: 0 + 50 => 50\n    Derivation--\x3e>Derivation: Register: 50 - 75 => -25\n    Derivation->>Publish \u03bb: publish({sender: alice, amount: 75, ...}, register = -25, previous = 50)?\n    Publish \u03bb--\x3e>Derivation: return {sender: alice, amount: 75, balance: -25, overdrawn: true}\n",mdxType:"Mermaid"}),(0,i.kt)("h2",{id:"processing-order"},"Processing Order"),(0,i.kt)("p",null,"Derivations may have multiple transformations that simultaneously read from\ndifferent source collections, or even multiple transformations that read\nfrom the same source collection."),(0,i.kt)("p",null,"Roughly speaking, the derivation will globally process transformations and\ntheir source documents in the time-based order by which the source documents\nwere originally written to their source collections.\nThis means that a derivation started a month ago,\nand a new copy of the derivation started today,\nwill process documents in the same order and arrive at the same result.\nDerivations are ",(0,i.kt)("strong",{parentName:"p"},"repeatable"),"."),(0,i.kt)("p",null,"More precisely, processing order is stable for each individual shuffle key,\nthough different shuffle keys may process in different orders if more than\none task shard is used."),(0,i.kt)("p",null,"Processing order can be attenuated through a ",(0,i.kt)("strong",{parentName:"p"},"read delay"),"\nor differing transformation ",(0,i.kt)("strong",{parentName:"p"},"priority"),"."),(0,i.kt)("h2",{id:"read-delay"},"Read Delay"),(0,i.kt)("p",null,"A transformation can define a read delay which will hold back the processing\nof its source documents until the time delay condition is met.\nFor example, a read delay of 15 minutes would mean that a source document\ncannot be processed until it was published at least 15 minutes ago.\nIf the derivation is working through a historical backlog of source documents,\nthan a delayed transformation will respect its ordering delay relative\nto the publishing times of other historical documents also being read."),(0,i.kt)("p",null,"Event-driven workflows are a great fit for reacting to events as they occur,\nbut aren\u2019t terribly good at taking action when something ",(0,i.kt)("em",{parentName:"p"},"hasn\u2019t")," happened:"),(0,i.kt)("blockquote",null,(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"A user adds a product to their cart, but then doesn\u2019t complete a purchase."),(0,i.kt)("li",{parentName:"ul"},"A temperature sensor stops producing its expected, periodic measurements."))),(0,i.kt)("p",null,"A common pattern for tackling these workflows in Flow is to\nread a source collection without a delay and update a register.\nThen, read a collection with a read delay\nand determine whether the desired action has happened or not.\nFor example, source from a collection of sensor readings\nand index the last timestamp of each sensor in a register.\nThen, source the same collection again with a read delay:\nif the register timestamp isn't more recent\nthan the delayed source reading,\nthen the sensor failed to produce a measurement."),(0,i.kt)("p",null,"Flow read delays are very efficient and scale better\nthan managing very large numbers of fine-grain timers."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/blob/master/examples/citi-bike/idle-bikes.flow.yaml"},"Learn more from the Citi Bike idle bikes example")),(0,i.kt)("h2",{id:"read-priority"},"Read Priority"),(0,i.kt)("p",null,"Sometimes its required that ",(0,i.kt)("em",{parentName:"p"},"all")," documents of a source collection\nare processed by a transformation before ",(0,i.kt)("em",{parentName:"p"},"any")," documents of some\nother source collection are processed, regardless of their\nrelative publishing time.\nFor example, a collection may have corrections which should be\napplied before the historical data of another collection\nis re-processed."),(0,i.kt)("p",null,"Transformation priorities allow for expressing the relative\nprocessing priority of a derivations various transformations.\nWhen priorities are not equal, ",(0,i.kt)("em",{parentName:"p"},"all")," available source documents\nof a higher-priority transformation\nare processed before ",(0,i.kt)("em",{parentName:"p"},"any")," source documents\nof a lower-priority transformation."),(0,i.kt)("h2",{id:"where-to-accumulate"},"Where to accumulate?"),(0,i.kt)("p",null,"When you build a derived collection, you must choose where ",(0,i.kt)("strong",{parentName:"p"},"accumulation")," will happen:\nwhether Flow will reduce into documents held within\nyour materialization endpoint, or within the derivation's registers.\nThese two approaches can produce equivalent results\nbut they do so in very different ways."),(0,i.kt)("h3",{id:"accumulate-in-your-database"},"Accumulate in your Database"),(0,i.kt)("p",null,"To accumulate in your materialization endpoint, such as a database,\nyou define a derivation with a reducible schema\nand use only ",(0,i.kt)("inlineCode",{parentName:"p"},"publish")," lambdas and no registers.\nThe Flow runtime uses your reduction annotations\nto combine published documents which are written to the collection,\nand also to fully reduce collection documents into the values\nstored in the database,\nkeeping the materialized table up to date."),(0,i.kt)("p",null,"A key insight is that the database is\nthe ",(0,i.kt)("em",{parentName:"p"},"only")," stateful system in this scenario,\nand Flow uses reductions in two steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"To combine many published documents into intermediate ",(0,i.kt)("strong",{parentName:"li"},"delta documents"),",\nwhich are the documents written to collection storage."),(0,i.kt)("li",{parentName:"ol"},"To reduce delta states into the final database-stored document.")),(0,i.kt)("p",null,"For example, consider a collection that\u2019s summing a value:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Time"),(0,i.kt)("th",{parentName:"tr",align:null},"DB"),(0,i.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,i.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T0"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0")),(0,i.kt)("td",{parentName:"tr",align:null},"publish(2, 1, 2)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"5"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T1"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"5")),(0,i.kt)("td",{parentName:"tr",align:null},"publish(-2, 1)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"-1"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T2"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"4")),(0,i.kt)("td",{parentName:"tr",align:null},"publish(3, -2, 1)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"2"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T3"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"6")),(0,i.kt)("td",{parentName:"tr",align:null},"publish()"),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,"This works especially well when materializing into a transactional database.\nFlow couples its processing transactions with corresponding database transactions,\nensuring end-to-end \u201cexactly once\u201d semantics."),(0,i.kt)("p",null,'When materializing into a non-transactional store,\nFlow is only able to provide weaker \u201cat least once\u201d semantics:\nit\u2019s possible that a document may be combined into a database value more than once.\nWhether that\u2019s a concern depends a bit on the task at hand.\nSome reductions can be applied repeatedly without changing the result (they\'re "idempotent"),\nand in other use-cases approximations are acceptable.\nFor the summing example above,\n"at-least-once" semantics could give an incorrect result.'),(0,i.kt)("h3",{id:"accumulate-in-registers"},"Accumulate in Registers"),(0,i.kt)("p",null,"To accumulate in registers,\nyou use a derivation that defines a reducible register schema\nthat's updated through ",(0,i.kt)("strong",{parentName:"p"},"update")," lambdas.\nThe Flow runtime allocates, manages, and scales durable storage for registers; you don\u2019t have to.\nThen you use ",(0,i.kt)("strong",{parentName:"p"},"publish")," lambdas to publish a snapshot of your register value into your collection."),(0,i.kt)("p",null,"Returning to our summing example:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Time"),(0,i.kt)("th",{parentName:"tr",align:null},"Register"),(0,i.kt)("th",{parentName:"tr",align:null},"Lambdas"),(0,i.kt)("th",{parentName:"tr",align:null},"Derived Document"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T0"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"0")),(0,i.kt)("td",{parentName:"tr",align:null},"update(2, 1, 2), publish(register)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"5"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T1"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"5")),(0,i.kt)("td",{parentName:"tr",align:null},"update(-2, 1), publish(register)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"4"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T2"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"4")),(0,i.kt)("td",{parentName:"tr",align:null},"update(3, -2, 1), publish(register)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"6"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"T3"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"6")),(0,i.kt)("td",{parentName:"tr",align:null},"update()"),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("p",null,"Register derivations are a great solution for materializations\ninto non-transactional stores\nbecause the documents they produce\ncan be applied multiple times without breaking correctness."),(0,i.kt)("p",null,"They\u2019re also well-suited for materializations into endpoints which aren't stateful,\nsuch as pub/sub systems or Webhooks,\nbecause they can produce fully reduced values as stand-alone updates."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/estuary/flow/tree/master/examples/derive-patterns"},"Learn more in the derivation pattern examples of Flow's repository")))}f.isMDXComponent=!0},9353:function(e,n,t){n.Z=t.p+"assets/images/derivations-500b54a86dbe549f575606b237429484.svg"}}]);